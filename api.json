[
	{
		"name": "foundations",
		"apis": [
			{
				"name": "Icon",
				"composition": [
					{
						"name": "Icon",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "alt",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Alternative text describing the icon.\n\nWhen this prop is passed, the SVG gets rendered as `role=\"img\"` and labelled\nusing the provided text.\n\nThis prop is not required if the icon is purely decorative. By default, the icon\nwill be hidden from the accessibility tree."
							},
							{
								"name": "href",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "URL of the `.svg` file (e.g. from `@stratakit/icons`).\n\nThe URL can contain a hash pointing to a specific symbol within the SVG (e.g. `#icon`, `#icon-large`).\nBy default, the `#icon` symbol is used if no hash is provided.\n\nNote: The `.svg` must be an external HTTP resource for it to be processed by\nthe `<use>` element. As a fallback, JS will be used to `fetch` the SVG from\nnon-supported URLs; the fetched SVG content will be sanitized using the\n`unstable_htmlSanitizer` function passed to `<Root>`."
							},
							{
								"name": "size",
								"type": "\"regular\" | \"large\" | undefined",
								"optional": true,
								"jsdoc": "Size of the icon. This only affects the icon's physical dimensions (not the SVG contents).\n\nDefaults to `\"regular\"` (16px) and can be optionally set to `\"large\"` (24px)."
							}
						],
						"baseElement": "svg",
						"jsdoc": "Icon component that provides fill and sizing to the SVGs from `@stratakit/icons`.\n\n```tsx\nconst arrowIcon = new URL(\"@stratakit/icons/arrow.svg\", import.meta.url).href;\n<Icon href={arrowIcon} />\n```\n\nThe `href` can point to a specific symbol (e.g. `#icon`, `#icon-large`) within the SVG file:\n\n```tsx\n<Icon href={`${arrowIcon}#icon-large`} />\n```\n\nIt also accepts a custom SVG, via the `render `prop:\n\n```tsx\n<Icon render={<svg><path d=\"…\" fill=\"currentColor\" /></svg>} />\n```\n\nBy default, this component assumes that the icon is decorative, so it adds `aria-hidden` by default.\n\nIf the icon is semantically meaningful, the `alt` prop can be used to provide alternative text.\n\n```tsx\n<Icon href={…} alt=\"Help\" />\n```",
						"barrelName": "Icon"
					}
				]
			},
			{
				"name": "Root",
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "colorScheme",
								"type": "\"light\" | \"dark\"",
								"optional": false,
								"jsdoc": "The color scheme to use for all components under the Root."
							},
							{
								"name": "density",
								"type": "\"dense\"",
								"optional": false,
								"jsdoc": "The density to use for all components under the Root."
							},
							{
								"name": "portalContainer",
								"type": "ReactElement<unknown, string | JSXElementConstructor<any>> | undefined",
								"optional": true,
								"jsdoc": "Allows to customize the root portal container element."
							},
							{
								"name": "rootNode",
								"type": "Document | ShadowRoot | undefined",
								"optional": true,
								"jsdoc": "The root node to which this `Root` component is attached.\n\nThis needs to be set when the `Root` is rendered within shadow DOM or a popout window.",
								"defaultValue": "document"
							},
							{
								"name": "synchronizeColorScheme",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Whether to synchronize the color scheme with the parent document (or shadow-root host).\n\nThis is useful when you don't have explicit control over the color scheme of the host.\n\nIt can be disabled if you want to isolate StrataKit's styles to `<Root>` and its descendants.",
								"defaultValue": "true"
							},
							{
								"name": "unstable_htmlSanitizer",
								"type": "((html: string) => string) | undefined",
								"optional": true,
								"jsdoc": "An HTML sanitizer function that will be used across all components wherever DOM elements\nare created from HTML strings.\n\nWhen this prop is not passed, sanitization will be skipped.\n\nExample:\n```tsx\nunstable_htmlSanitizer={DOMPurify.sanitize}\n```"
							}
						],
						"baseElement": "div",
						"jsdoc": "Component to be used at the root of your application. It ensures that StrataKit styles and fonts are loaded\nand automatically applied to the current page or the encompassing shadow-root.\n\nMake sure to specify the `colorScheme` and `density` props.\n\nExample:\n```tsx\n<Root colorScheme=\"dark\" density=\"dense\">\n  <App />\n</Root>\n```",
						"barrelName": "Root"
					}
				]
			},
			{
				"name": "Utils",
				"exportName": "Internal Utils",
				"description": "Utility types used by StrataKit components.",
				"composition": [],
				"types": [
					{
						"name": "BaseProps",
						"props": [
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							}
						],
						"jsdoc": "Base component props with custom props."
					},
					{
						"name": "FocusableProps",
						"props": [
							{
								"name": "accessibleWhenDisabled",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Indicates whether the element should be focusable even when it is\n[`disabled`](https://ariakit.org/reference/focusable#disabled).\n\nThis is important when discoverability is a concern. For example:\n\n> A toolbar in an editor contains a set of special smart paste functions\nthat are disabled when the clipboard is empty or when the function is not\napplicable to the current content of the clipboard. It could be helpful to\nkeep the disabled buttons focusable if the ability to discover their\nfunctionality is primarily via their presence on the toolbar.\n\nLearn more on [Focusability of disabled\ncontrols](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols)."
							},
							{
								"name": "autoFocus",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Automatically focuses the element upon mounting, similar to the native\n`autoFocus` prop. This addresses an issue where the element with the native\n`autoFocus` attribute might receive focus before React effects are\nexecuted.\n\nThe `autoFocus` prop can also be used with\n[Focusable](https://ariakit.org/components/focusable) elements within a\n[Dialog](https://ariakit.org/components/dialog) component, establishing the\ninitial focus as the dialog opens.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
								"defaultValue": "false"
							},
							{
								"name": "disabled",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Determines if the element is disabled. This sets the `aria-disabled`\nattribute accordingly, enabling support for all elements, including those\nthat don't support the native `disabled` attribute.\n\nThis feature can be combined with the\n[`accessibleWhenDisabled`](https://ariakit.org/reference/focusable#accessiblewhendisabled)\nprop to make disabled elements still accessible via keyboard.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
								"defaultValue": "false"
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							}
						],
						"jsdoc": "Focusable component props with custom props."
					}
				]
			}
		]
	},
	{
		"name": "bricks",
		"apis": [
			{
				"name": "Anchor",
				"convenience": {
					"name": "Anchor",
					"baseProps": [
						"FocusableProps.render",
						"FocusableProps.autoFocus",
						"FocusableProps.disabled",
						"FocusableProps.accessibleWhenDisabled"
					],
					"props": [
						{
							"name": "tone",
							"type": "\"neutral\" | \"accent\" | undefined",
							"optional": true,
							"defaultValue": "\"neutral\""
						}
					],
					"baseElement": "a",
					"jsdoc": "A styled anchor element, typically used for navigating to a different location.",
					"barrelName": "Anchor"
				},
				"composition": [
					{
						"name": "Root",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [
							{
								"name": "tone",
								"type": "\"neutral\" | \"accent\" | undefined",
								"optional": true,
								"defaultValue": "\"neutral\""
							}
						],
						"baseElement": "a",
						"jsdoc": "A styled anchor element, typically used for navigating to a different location.\n\nSupports the convenience API (lesser code) and the composition API (more customization).\n\nExample of convenience API:\n```tsx\nimport { Anchor } from \"@stratakit/bricks\";\n\n<Anchor href=\"https://www.example.com\">Example</Anchor>\n```\n\nExample of composition API:\n```tsx\nimport * as Anchor from \"@stratakit/bricks/Anchor\";\n\n<Anchor.Root href=\"https://www.example.com\">Example</Anchor.Root>\n```"
					},
					{
						"name": "Text",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "children",
								"type": "ReactNode",
								"optional": false,
								"jsdoc": "The content displayed inside the anchor."
							}
						],
						"baseElement": "span",
						"jsdoc": "Displays the anchor text."
					},
					{
						"name": "ExternalMarker",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "alt",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Visually hidden text for screen readers.",
								"defaultValue": "\"external\""
							}
						],
						"baseElement": "span",
						"jsdoc": "Displays an external link marker, with visually hidden text for screen readers."
					}
				],
				"exportName": "Anchor"
			},
			{
				"name": "Avatar",
				"convenience": {
					"name": "Avatar",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "alt",
							"type": "string | undefined",
							"optional": true,
							"jsdoc": "Alternative text describing the avatar, typically the user's or organization's full name.\n\nWhen this prop is passed, the avatar gets rendered as `role=\"img\"` and labelled\nusing the provided text.\n\nThis prop is not required if the avatar is purely decorative. By default, the avatar\nwill be hidden from the accessibility tree."
						},
						{
							"name": "image",
							"type": "Element | undefined",
							"optional": true,
							"jsdoc": "Image to be displayed. Can be `<img>` or `<svg>` or anything else."
						},
						{
							"name": "initials",
							"type": "string | undefined",
							"optional": true,
							"jsdoc": "Initials that gets displayed in the absence of an image."
						},
						{
							"name": "size",
							"type": "\"small\" | \"medium\" | \"large\" | \"xlarge\" | undefined",
							"optional": true,
							"jsdoc": "The size of the avatar.",
							"defaultValue": "\"medium\""
						}
					],
					"baseElement": "span",
					"jsdoc": "An avatar to represent a user or organization.\n\nBy default, this component assumes that the avatar is decorative, so it adds `aria-hidden` by default.\n```tsx\n<Avatar initials=\"JD\" />\n```\n\nIf the avatar is semantically meaningful, the `alt` prop can be used to provide alternative text.\n```tsx\n<Avatar initials=\"JD\" alt=\"John Doe\" />\n```\n\nImage & size examples:\n```tsx\n<Avatar initials=\"JD\" alt=\"John Doe\" size=\"xlarge\" image={<img src=\"…\" alt=\"\">} />\n<Avatar initials=\"JD\" alt=\"John Doe\" size=\"small\" image={<Icon href=\"…\">} />\n```",
					"barrelName": "Avatar"
				},
				"composition": [],
				"exportName": "Avatar"
			},
			{
				"name": "Badge",
				"convenience": {
					"name": "Badge",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "label",
							"type": "ReactNode",
							"optional": false,
							"jsdoc": "The label displayed inside the badge."
						},
						{
							"name": "icon",
							"type": "string | Element | undefined",
							"optional": true,
							"jsdoc": "Icon to be displayed at the start of the badge.\n\nCan be a URL of an SVG from the `@stratakit/icons` package,\nor a custom JSX icon."
						},
						{
							"name": "tone",
							"type": "\"neutral\" | \"accent\" | \"info\" | \"positive\" | \"attention\" | \"critical\" | undefined",
							"optional": true,
							"jsdoc": "The tone of the badge.",
							"defaultValue": "\"neutral\""
						},
						{
							"name": "variant",
							"type": "\"solid\" | \"muted\" | \"outline\" | undefined",
							"optional": true,
							"jsdoc": "The variant style of the badge.",
							"defaultValue": "\"solid\""
						}
					],
					"baseElement": "span",
					"jsdoc": "A badge component, typically used to designate the status of an item.\n\nExample:\n```tsx\n<Badge label=\"Value\" />\n<Badge label=\"Value\" tone=\"info\" variant=\"outline\" icon={…} />\n```",
					"barrelName": "Badge"
				},
				"composition": [],
				"exportName": "Badge"
			},
			{
				"name": "Button",
				"convenience": {
					"name": "Button",
					"baseProps": [
						"FocusableProps.render",
						"FocusableProps.autoFocus",
						"FocusableProps.disabled",
						"FocusableProps.accessibleWhenDisabled"
					],
					"props": [
						{
							"name": "tone",
							"type": "\"neutral\" | \"accent\" | undefined",
							"optional": true,
							"jsdoc": "The tone of the button. Most buttons should be neutral.\nAccent buttons can be used to draw attention to the primary action.",
							"defaultValue": "\"neutral\""
						},
						{
							"name": "variant",
							"type": "\"solid\" | \"outline\" | \"ghost\" | undefined",
							"optional": true,
							"jsdoc": "The variant of the button, i.e. solid, outline, or ghost.",
							"defaultValue": "\"solid\""
						}
					],
					"baseElement": "button",
					"jsdoc": "A styled button element which allows the user to perform an action when clicked.\n\nExample:\n```tsx\n<Button onClick={() => doSomething()}>Click me</Button>\n```\n\nStart and end icons can be added by passing `Icon` as children.\n\n```tsx\n<Button>\n  <Icon href={…} />\n  Click me\n  <Icon href={…} />\n</Button>\n```\n\nThe button's appearance can be customized using the `variant` and `tone` props.",
					"barrelName": "Button"
				},
				"composition": [],
				"exportName": "Button"
			},
			{
				"name": "Checkbox",
				"convenience": {
					"name": "Checkbox",
					"baseProps": [],
					"props": [
						{
							"name": "accessibleWhenDisabled",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Indicates whether the element should be focusable even when it is\n[`disabled`](https://ariakit.org/reference/focusable#disabled).\n\nThis is important when discoverability is a concern. For example:\n\n> A toolbar in an editor contains a set of special smart paste functions\nthat are disabled when the clipboard is empty or when the function is not\napplicable to the current content of the clipboard. It could be helpful to\nkeep the disabled buttons focusable if the ability to discover their\nfunctionality is primarily via their presence on the toolbar.\n\nLearn more on [Focusability of disabled\ncontrols](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols)."
						},
						{
							"name": "autoFocus",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Automatically focuses the element upon mounting, similar to the native\n`autoFocus` prop. This addresses an issue where the element with the native\n`autoFocus` attribute might receive focus before React effects are\nexecuted.\n\nThe `autoFocus` prop can also be used with\n[Focusable](https://ariakit.org/components/focusable) elements within a\n[Dialog](https://ariakit.org/components/dialog) component, establishing the\ninitial focus as the dialog opens.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
							"defaultValue": "false"
						},
						{
							"name": "checked",
							"type": "boolean | \"mixed\" | undefined",
							"optional": true,
							"jsdoc": "The checked state of the checkbox. This will override the value inferred\nfrom [`store`](https://ariakit.org/reference/checkbox#store) prop, if\nprovided. This can be `\"mixed\"` to indicate that the checkbox is partially\nchecked."
						},
						{
							"name": "defaultChecked",
							"type": "boolean | \"mixed\" | undefined",
							"optional": true,
							"jsdoc": "The default checked state of the checkbox. This prop is ignored if the\n[`checked`](https://ariakit.org/reference/checkbox#checked) or the\n[`store`](https://ariakit.org/reference/checkbox#store) props are provided."
						},
						{
							"name": "disabled",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Determines if the element is disabled. This sets the `aria-disabled`\nattribute accordingly, enabling support for all elements, including those\nthat don't support the native `disabled` attribute.\n\nThis feature can be combined with the\n[`accessibleWhenDisabled`](https://ariakit.org/reference/focusable#accessiblewhendisabled)\nprop to make disabled elements still accessible via keyboard.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
							"defaultValue": "false"
						},
						{
							"name": "onChange",
							"type": "ChangeEventHandler<HTMLInputElement> | undefined",
							"optional": true,
							"jsdoc": "A function that is called when the checkbox's checked state changes."
						},
						{
							"name": "render",
							"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
							"optional": true,
							"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
						},
						{
							"name": "value",
							"type": "string | number | readonly string[] | undefined",
							"optional": true,
							"jsdoc": "The value of the checkbox. This is useful when the same checkbox store is\nused for multiple [`Checkbox`](https://ariakit.org/reference/checkbox)\nelements, in which case the value will be an array of checked values."
						}
					],
					"baseElement": "input",
					"jsdoc": "A styled checkbox element, typically used for selecting one or more options from a list.\n\nUse with the `Field` components to automatically handle ID associations for\nlabels and descriptions:\n```tsx\n<Field.Root>\n  <Field.Label>Check me</Field.Label>\n  <Field.Control render={<Checkbox />} />\n</Field.Root>\n```\n\nWithout the `Field` components you will need to manually associate labels,\ndescriptions, etc.:\n```tsx\n<Checkbox id=\"newsletter\" name=\"newsletter\" aria-describedby=\"newsletter-description\" />\n<Label htmlFor=\"newsletter\">Sign me up for the newsletter.</Label>\n<Description id=\"newsletter-description\">No spam, we promise.</Description>\n```\n\nUnderneath, it's an HTML checkbox, i.e. `<input type=\"checkbox\">`, so it supports the same props,\nincluding `value`, `defaultChecked`, `checked`, and `onChange`.",
					"barrelName": "Checkbox"
				},
				"composition": [],
				"exportName": "Checkbox"
			},
			{
				"name": "Description",
				"convenience": {
					"name": "Description",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "tone",
							"type": "\"neutral\" | \"critical\" | undefined",
							"optional": true,
							"jsdoc": "The tone of the description.",
							"defaultValue": "\"neutral\""
						}
					],
					"baseElement": "div",
					"jsdoc": "A presentational description.\n\nSee `Field.Description` for convenient usage with form controls.",
					"barrelName": "Description"
				},
				"composition": [],
				"exportName": "Description"
			},
			{
				"name": "Divider",
				"convenience": {
					"name": "Divider",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "bleed",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "If true, the divider will extend to the edges of the nearest scrollable container.",
							"defaultValue": "false"
						},
						{
							"name": "orientation",
							"type": "\"horizontal\" | \"vertical\" | undefined",
							"optional": true,
							"jsdoc": "The orientation of the separator.",
							"defaultValue": "\"horizontal\""
						},
						{
							"name": "presentational",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "If true, the divider will be purely presentational and will not have any associated semantics.",
							"defaultValue": "false"
						}
					],
					"baseElement": "hr",
					"jsdoc": "A styled \"separator\" element (e.g. `<hr>`), useful for grouping and dividing content within a layout.\n\nA `Divider` can be oriented horizontally or vertically (using the `orientation` prop),\nand can be a semantic divider or a purely presentational one (using the `presentational` prop).",
					"barrelName": "Divider"
				},
				"composition": [],
				"exportName": "Divider"
			},
			{
				"name": "Field",
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "layout",
								"type": "\"inline\" | undefined",
								"optional": true,
								"jsdoc": "Allows overriding the default block layout for text controls."
							}
						],
						"baseElement": "div",
						"jsdoc": "A container for form controls. It manages ID associations, and provides a\nconsistent layout and spacing.\n\nExample:\n```tsx\n<Field.Root>\n  <Field.Label>Label</Field.Label>\n  <Field.Control render={<TextBox.Input />} />\n</Field.Root>\n```\n\nSupports a `layout` prop, which can be set to `inline` to align the label and\ncontrol horizontally.\n\nShould contain a `Field.Label` component paired with a form control.\n\nSupported form controls include:\n- `TextBox.Input`\n- `TextBox.Textarea`\n- `Checkbox`\n- `Radio`\n- `Switch`",
						"barrelName": "Field.Root"
					},
					{
						"name": "Control",
						"baseProps": [],
						"props": [
							{
								"name": "render",
								"type": "Element | ((props: Omit<HTMLAttributes<any> & { ref?: Ref<any> | undefined; }, \"children\">) => ReactNode)",
								"optional": false
							},
							{
								"name": "id",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "The unique ID of the item. This will be used to register the item in the\nstore and for the element's `id` attribute. If not provided, a unique ID\nwill be automatically generated."
							}
						],
						"baseElement": "div",
						"jsdoc": "The control component for the field.\n\nUse the `render` prop to render the control component.\n\n```tsx\n<Field.Control render={<TextBox.Input />} />\n```\n\nIf the rendered component uses a compositional API, then use a function\nwithin `render` to apply the `controlProps` to the correct sub-component:\n\n```tsx\n<Field.Control\n  render={(controlProps) => (\n    <TextBox.Root>\n      <TextBox.Icon href={placeholder} />\n      <TextBox.Input {...controlProps} />\n    </TextBox.Root>\n  )}\n/>\n```\n\nIf you need a custom `id` set for the control, set it on this component\ninstead of the control component within `render`.\n\n```tsx\n<Field.Control id=\"custom\" render={<TextBox.Input />} />\n```",
						"barrelName": "Field.Control"
					},
					{
						"name": "Label",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "label",
						"jsdoc": "A label for the field’s control element. This is automatically associated\nwith the control’s `id`.",
						"barrelName": "Field.Label"
					},
					{
						"name": "Description",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "A description for the field’s control element. This is automatically\nassociated with the control.\n\nShould not include content without an adequate text alternative (e.g.\ninteractive elements).",
						"barrelName": "Field.Description"
					},
					{
						"name": "ErrorMessage",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "An associated error message for a field. When used within `<Field.Root>`, the\nassociated form control will be rendered with `aria-invalid=\"true\"`.\n\nExample:\n```tsx\n<Field.Root>\n  <Field.Label>Label</Field.Label>\n  <Field.Control render={<TextBox.Input />} />\n  <Field.ErrorMessage>Something is wrong!</Field.ErrorMessage>\n</Field.Root>\n```",
						"barrelName": "Field.ErrorMessage"
					}
				],
				"exportName": "Field"
			},
			{
				"name": "IconButton",
				"convenience": {
					"name": "IconButton",
					"baseProps": [],
					"props": [
						{
							"name": "icon",
							"type": "string | Element",
							"optional": false,
							"jsdoc": "Icon to be displayed inside the button.\n\nCan be a URL of an SVG from the `@stratakit/icons` package,\nor a custom JSX icon."
						},
						{
							"name": "label",
							"type": "string",
							"optional": false,
							"jsdoc": "Accessible name for the button.\n\nThis label gets used by assistive technology to identify the button,\nand also gets shown in a tooltip by default."
						},
						{
							"name": "accessibleWhenDisabled",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Indicates whether the element should be focusable even when it is\n[`disabled`](https://ariakit.org/reference/focusable#disabled).\n\nThis is important when discoverability is a concern. For example:\n\n> A toolbar in an editor contains a set of special smart paste functions\nthat are disabled when the clipboard is empty or when the function is not\napplicable to the current content of the clipboard. It could be helpful to\nkeep the disabled buttons focusable if the ability to discover their\nfunctionality is primarily via their presence on the toolbar.\n\nLearn more on [Focusability of disabled\ncontrols](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols)."
						},
						{
							"name": "active",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Whether the button is in a toggled state and currently \"active\" (toggled on).\n\nFor regular buttons, setting this prop to `true` or `false` will turn this button into a toggle button.\nThe button will have an `aria-pressed` attribute and extra styling for the \"active\" state.\nWhen this prop is `undefined`, the button will be a regular button (no `aria-pressed` attribute).\n\nWhen the button is rendered as an anchor (`<a>`), this prop maps to `aria-current` instead of `aria-pressed`.",
							"defaultValue": "undefined"
						},
						{
							"name": "autoFocus",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Automatically focuses the element upon mounting, similar to the native\n`autoFocus` prop. This addresses an issue where the element with the native\n`autoFocus` attribute might receive focus before React effects are\nexecuted.\n\nThe `autoFocus` prop can also be used with\n[Focusable](https://ariakit.org/components/focusable) elements within a\n[Dialog](https://ariakit.org/components/dialog) component, establishing the\ninitial focus as the dialog opens.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
							"defaultValue": "false"
						},
						{
							"name": "disabled",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Determines if the element is disabled. This sets the `aria-disabled`\nattribute accordingly, enabling support for all elements, including those\nthat don't support the native `disabled` attribute.\n\nThis feature can be combined with the\n[`accessibleWhenDisabled`](https://ariakit.org/reference/focusable#accessiblewhendisabled)\nprop to make disabled elements still accessible via keyboard.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
							"defaultValue": "false"
						},
						{
							"name": "dot",
							"type": "string | undefined",
							"optional": true,
							"jsdoc": "A small dot displayed in the corner of the icon.\n\nThe value of this prop gets used as the button's \"accessible description\".\n\nExample:\n```tsx\n<IconButton\n  label=\"Messages\"\n  dot=\"You have unread messages\"\n  icon={…}\n/>\n```"
						},
						{
							"name": "key",
							"type": "Key | null | undefined",
							"optional": true
						},
						{
							"name": "labelVariant",
							"type": "\"tooltip\" | \"visually-hidden\" | undefined",
							"optional": true,
							"jsdoc": "Behavior of the label.\n\nBy default, the label is shown in a tooltip. Use `\"visually-hidden\"` to\nhide the label from sighted users.",
							"defaultValue": "\"tooltip\""
						},
						{
							"name": "ref",
							"type": "Ref<HTMLElement | HTMLButtonElement> | undefined",
							"optional": true,
							"jsdoc": "Allows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref)."
						},
						{
							"name": "render",
							"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
							"optional": true,
							"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
						},
						{
							"name": "variant",
							"type": "\"solid\" | \"outline\" | \"ghost\" | undefined",
							"optional": true,
							"jsdoc": "The variant of the button, i.e. solid, outline, or ghost.",
							"defaultValue": "\"solid\""
						}
					],
					"baseElement": "button",
					"jsdoc": "An icon-only button, with a required accessible name.\n\nThe icon can be a URL from the `@stratakit/icons` package:\n```tsx\n<IconButton\n  label=\"Reveal full content\"\n  icon={new URL(\"@stratakit/icons/arrow.svg\", import.meta.url).href}\n/>\n```\n\nAlternatively, pass a JSX node such as an `<Icon>`.\n```tsx\n<IconButton\n  label={…}\n  icon={<Icon href={…} />}\n  variant=\"ghost\"\n/>\n```\n\nThe `active` prop can be used to turn this button into a toggle button.\n```tsx\nconst [active, setActive] = React.useState(false);\n\n<IconButton\n  label={…}\n  icon={…}\n  active={active}\n  onClick={() => setActive(!active)}\n/>\n```",
					"barrelName": "IconButton"
				},
				"composition": [],
				"exportName": "IconButton"
			},
			{
				"name": "Kbd",
				"convenience": {
					"name": "Kbd",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "symbol",
							"type": "\"Tab\" | \"Backspace\" | \"Command\" | \"Control\" | \"Down\" | \"Eject\" | \"Enter\" | \"Escape\" | \"Left\" | \"Option\" | \"Right\" | \"Shift\" | \"Space\" | \"Up\" | undefined",
							"optional": true,
							"jsdoc": "Display a specific key symbol from a predefined list. This is useful for\ndisplaying modifier keys or special keys, such as `Control`, `Shift`, `Enter`, etc.\n\nExample:\n```tsx\n<Kbd symbol=\"Control\" />\n```"
						},
						{
							"name": "variant",
							"type": "\"solid\" | \"muted\" | \"ghost\" | undefined",
							"optional": true,
							"defaultValue": "\"solid\""
						}
					],
					"baseElement": "kbd",
					"jsdoc": "A styled wrapper over the HTML `<kbd>` element. This is typically\nused for displaying keyboard shortcuts.\n\n```tsx\n<Kbd>Ctrl</Kbd> <Kbd>S</Kbd>\n```\n\n```tsx\n<Kbd symbol=\"Control\" />\n```",
					"barrelName": "Kbd"
				},
				"composition": [],
				"exportName": "Kbd"
			},
			{
				"name": "Label",
				"convenience": {
					"name": "Label",
					"baseProps": ["BaseProps.render"],
					"props": [],
					"baseElement": "label",
					"jsdoc": "A styled wrapper over the HTML `<label>` element, used for labelling form\ncontrols.\n\nExample usage:\n```tsx\n<Label htmlFor=\"my-input\">Label</Label>\n<TextBox.Input id=\"my-input\" />\n```\n\nSee `Field.Label` for convenient usage with form controls (e.g. automatic\nassociation with adjacent form control).",
					"barrelName": "Label"
				},
				"composition": [],
				"exportName": "Label"
			},
			{
				"name": "Progress",
				"composition": [
					{
						"name": "ProgressBar",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "aria-labelledby",
								"type": "string",
								"optional": false,
								"jsdoc": "Label for the progress bar.\n\nThis prop is required because `role=\"progressbar\"` requires an accessible name."
							},
							{
								"name": "size",
								"type": "\"medium\" | \"large\" | undefined",
								"optional": true,
								"jsdoc": "The size of the progress bar.",
								"defaultValue": "\"medium\""
							},
							{
								"name": "tone",
								"type": "\"neutral\" | \"accent\" | undefined",
								"optional": true,
								"jsdoc": "The tone of the progress bar.",
								"defaultValue": "\"neutral\""
							},
							{
								"name": "value",
								"type": "number | undefined",
								"optional": true,
								"jsdoc": "The value of the progress bar between 0 and 100 (inclusive). This value is rounded to 3 decimal places.\n\n- If passed, the progress bar will be determinate.\n- If not passed, the progress bar will be indeterminate.\n\nNote: Indeterminate progress bars (`value` not passed) should only be used for indicating the progress of short\noperations (i.e. less than 5 seconds)."
							}
						],
						"baseElement": "div",
						"jsdoc": "A linear progress bar for indicating progress of an operation (or loading of data).\nThis component maps to the [ARIA `progressbar` role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/progressbar_role)\nand must be labelled using `aria-labelledby`.\n\nNote: A progress bar is indeterminate if no `value` is passed.\n\nExample:\n```tsx\n<ProgressBar aria-labelledby={…} /> // indeterminate\n<ProgressBar aria-labelledby={…} value={50} /> // determinate\n```\n\nSupports a `tone` prop to change the tone (color) of the progress bar.\nSupports a `size` prop to change the size of the progress bar.",
						"barrelName": "ProgressBar"
					}
				],
				"exportName": "Progress"
			},
			{
				"name": "Radio",
				"convenience": {
					"name": "Radio",
					"baseProps": [],
					"props": [
						{
							"name": "value",
							"type": "string | number",
							"optional": false,
							"jsdoc": "The value of the radio button."
						},
						{
							"name": "accessibleWhenDisabled",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Indicates whether the element should be focusable even when it is\n[`disabled`](https://ariakit.org/reference/focusable#disabled).\n\nThis is important when discoverability is a concern. For example:\n\n> A toolbar in an editor contains a set of special smart paste functions\nthat are disabled when the clipboard is empty or when the function is not\napplicable to the current content of the clipboard. It could be helpful to\nkeep the disabled buttons focusable if the ability to discover their\nfunctionality is primarily via their presence on the toolbar.\n\nLearn more on [Focusability of disabled\ncontrols](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols)."
						},
						{
							"name": "autoFocus",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Automatically focuses the element upon mounting, similar to the native\n`autoFocus` prop. This addresses an issue where the element with the native\n`autoFocus` attribute might receive focus before React effects are\nexecuted.\n\nThe `autoFocus` prop can also be used with\n[Focusable](https://ariakit.org/components/focusable) elements within a\n[Dialog](https://ariakit.org/components/dialog) component, establishing the\ninitial focus as the dialog opens.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
							"defaultValue": "false"
						},
						{
							"name": "checked",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Determines if the radio button is checked. Using this prop will make the\nradio button controlled and override the\n[`value`](https://ariakit.org/reference/radio-provider#value) state."
						},
						{
							"name": "disabled",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Determines if the element is disabled. This sets the `aria-disabled`\nattribute accordingly, enabling support for all elements, including those\nthat don't support the native `disabled` attribute.\n\nThis feature can be combined with the\n[`accessibleWhenDisabled`](https://ariakit.org/reference/focusable#accessiblewhendisabled)\nprop to make disabled elements still accessible via keyboard.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
							"defaultValue": "false"
						},
						{
							"name": "onChange",
							"type": "BivariantCallback<(event: ChangeEvent<HTMLInputElement>) => void> | undefined",
							"optional": true,
							"jsdoc": "Callback function that is called when the radio button state changes."
						},
						{
							"name": "render",
							"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
							"optional": true,
							"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
						}
					],
					"baseElement": "input",
					"jsdoc": "A styled radio input element, typically used for selecting a single option from a list.\n\nUse with the `Field` components to automatically handle ID associations for\nlabels and descriptions:\n```tsx\n<Field.Root>\n  <Field.Label>Choose one</Field.Label>\n  <Field.Control render={<Radio />} />\n</Field.Root>\n```\n\nWithout the `Field` components you will need to manually associate labels,\ndescriptions, etc.:\n```tsx\n<Radio id=\"editor-vim\" name=\"editor\" value=\"vim\" />\n<Label htmlFor=\"editor-vim\">Vim</Label>\n<Radio id=\"editor-emacs\" name=\"editor\" value=\"emacs\" />\n<Label htmlFor=\"editor-emacs\">Emacs</Label>\n```\n\nUnderneath, it's an HTML radio input, i.e. `<input type=\"radio\">`, so it supports the same props,\nincluding `value`, `defaultChecked`, `checked`, and `onChange`.",
					"barrelName": "Radio"
				},
				"composition": [],
				"exportName": "Radio"
			},
			{
				"name": "Select",
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "Compound component for a select element, which allows the user to select a value from a list of options.\n\nUse with the `Field` components to automatically handle ID associations for\nlabels and descriptions:\n```tsx\n<Field.Root>\n  <Field.Label>Fruit</Field.Label>\n  <Field.Control\n    render={(controlProps) => (\n      <Select.Root>\n        <Select.HtmlSelect name=\"fruit\" {...controlProps}>\n          <option value=\"kiwi\">Kiwi</option>\n          <option value=\"mango\">Mango</option>\n          <option value=\"papaya\">Papaya</option>\n        </Select.HtmlSelect>\n      </Select.Root>\n    )}\n  />\n</Field.Root>\n```\n\nWithout the `Field` components you will need to manually associate labels,\ndescriptions, etc.:\n```tsx\n<Label htmlFor=\"fruit\">Fruit</Label>\n<Description id=\"fruit-description\">Something to include in a fruit salad.</Description>\n<Select.Root>\n  <Select.HtmlSelect id=\"fruit\" aria-describedby=\"fruit-description\">\n    <option value=\"kiwi\">Kiwi</option>\n    <option value=\"mango\">Mango</option>\n    <option value=\"papaya\">Papaya</option>\n  </Select.HtmlSelect>\n</Select.Root>\n```",
						"barrelName": "Select.Root"
					},
					{
						"name": "HtmlSelect",
						"baseProps": [],
						"props": [
							{
								"name": "accessibleWhenDisabled",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Indicates whether the element should be focusable even when it is\n[`disabled`](https://ariakit.org/reference/focusable#disabled).\n\nThis is important when discoverability is a concern. For example:\n\n> A toolbar in an editor contains a set of special smart paste functions\nthat are disabled when the clipboard is empty or when the function is not\napplicable to the current content of the clipboard. It could be helpful to\nkeep the disabled buttons focusable if the ability to discover their\nfunctionality is primarily via their presence on the toolbar.\n\nLearn more on [Focusability of disabled\ncontrols](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols)."
							},
							{
								"name": "autoFocus",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Automatically focuses the element upon mounting, similar to the native\n`autoFocus` prop. This addresses an issue where the element with the native\n`autoFocus` attribute might receive focus before React effects are\nexecuted.\n\nThe `autoFocus` prop can also be used with\n[Focusable](https://ariakit.org/components/focusable) elements within a\n[Dialog](https://ariakit.org/components/dialog) component, establishing the\ninitial focus as the dialog opens.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
								"defaultValue": "false"
							},
							{
								"name": "disabled",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Determines if the element is disabled. This sets the `aria-disabled`\nattribute accordingly, enabling support for all elements, including those\nthat don't support the native `disabled` attribute.\n\nThis feature can be combined with the\n[`accessibleWhenDisabled`](https://ariakit.org/reference/focusable#accessiblewhendisabled)\nprop to make disabled elements still accessible via keyboard.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
								"defaultValue": "false"
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							},
							{
								"name": "variant",
								"type": "\"solid\" | \"outline\" | \"ghost\" | undefined",
								"optional": true,
								"jsdoc": "The variant of the `HtmlSelect`, i.e. solid, outline, or ghost.",
								"defaultValue": "\"solid\""
							}
						],
						"baseElement": "select",
						"jsdoc": "The actual select element to be used inside `Select.Root`. This is a wrapper around the\nHTML `<select>` element and should render HTML `<option>` elements as children.\n\nExample usage:\n```tsx\n<Select.HtmlSelect>\n  <option value=\"1\">Option 1</option>\n  <option value=\"2\">Option 2</option>\n  <option value=\"3\">Option 3</option>\n</Select.HtmlSelect>\n```\n\nThe usage of this component largely mirrors how the `<select>` element would be used in React.\nYou can use the same familiar props, including `name`, `defaultValue`, `value`, `onChange`, etc.",
						"barrelName": "Select.HtmlSelect"
					}
				],
				"exportName": "Select"
			},
			{
				"name": "Skeleton",
				"convenience": {
					"name": "Skeleton",
					"baseProps": [],
					"props": [
						{
							"name": "render",
							"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
							"optional": true,
							"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
						},
						{
							"name": "size",
							"type": "\"small\" | \"medium\" | \"large\" | \"xlarge\" | \"xsmall\" | undefined",
							"optional": true,
							"jsdoc": "The size of the skeleton item. Available sizes: `xsmall`, `small`, `medium`, `large`, `xlarge`",
							"defaultValue": "\"medium\""
						},
						{
							"name": "variant",
							"type": "\"object\" | \"text\" | undefined",
							"optional": true,
							"jsdoc": "The type of the skeleton item. Available variants: `text`, `object`.",
							"defaultValue": "\"text\""
						}
					],
					"baseElement": "div",
					"jsdoc": "Represents the loaded content before it finishes loading.\n\nExample:\n```tsx\n<Skeleton variant=\"object\" size=\"small\" shape=\"square\" />\n<Skeleton variant=\"text\" size=\"medium\" />\n```",
					"barrelName": "Skeleton"
				},
				"composition": [],
				"exportName": "Skeleton"
			},
			{
				"name": "Spinner",
				"convenience": {
					"name": "Spinner",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "alt",
							"type": "string | undefined",
							"optional": true,
							"jsdoc": "A text alternative for the spinner.",
							"defaultValue": "\"Loading…\""
						},
						{
							"name": "size",
							"type": "\"small\" | \"medium\" | \"large\" | \"xlarge\" | undefined",
							"optional": true,
							"jsdoc": "The size of the spinner.",
							"defaultValue": "\"medium\""
						},
						{
							"name": "tone",
							"type": "\"neutral\" | \"accent\" | undefined",
							"optional": true,
							"jsdoc": "The tone of the spinner.",
							"defaultValue": "\"neutral\""
						}
					],
					"baseElement": "div",
					"jsdoc": "A loading spinner.\n\nExample:\n```tsx\n<Spinner />\n```\n\nSupports a `tone` prop to change the tone (color) of the spinner.\nSupports a `size` prop to change the size of the spinner.",
					"barrelName": "Spinner"
				},
				"composition": [],
				"exportName": "Spinner"
			},
			{
				"name": "Switch",
				"convenience": {
					"name": "Switch",
					"baseProps": [],
					"props": [
						{
							"name": "accessibleWhenDisabled",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Indicates whether the element should be focusable even when it is\n[`disabled`](https://ariakit.org/reference/focusable#disabled).\n\nThis is important when discoverability is a concern. For example:\n\n> A toolbar in an editor contains a set of special smart paste functions\nthat are disabled when the clipboard is empty or when the function is not\napplicable to the current content of the clipboard. It could be helpful to\nkeep the disabled buttons focusable if the ability to discover their\nfunctionality is primarily via their presence on the toolbar.\n\nLearn more on [Focusability of disabled\ncontrols](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols)."
						},
						{
							"name": "autoFocus",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Automatically focuses the element upon mounting, similar to the native\n`autoFocus` prop. This addresses an issue where the element with the native\n`autoFocus` attribute might receive focus before React effects are\nexecuted.\n\nThe `autoFocus` prop can also be used with\n[Focusable](https://ariakit.org/components/focusable) elements within a\n[Dialog](https://ariakit.org/components/dialog) component, establishing the\ninitial focus as the dialog opens.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
							"defaultValue": "false"
						},
						{
							"name": "checked",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "The controlled checked state of the toggle switch."
						},
						{
							"name": "defaultChecked",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "The default checked state of the toggle switch."
						},
						{
							"name": "disabled",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Determines if the element is disabled. This sets the `aria-disabled`\nattribute accordingly, enabling support for all elements, including those\nthat don't support the native `disabled` attribute.\n\nThis feature can be combined with the\n[`accessibleWhenDisabled`](https://ariakit.org/reference/focusable#accessiblewhendisabled)\nprop to make disabled elements still accessible via keyboard.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
							"defaultValue": "false"
						},
						{
							"name": "onChange",
							"type": "ChangeEventHandler<HTMLInputElement> | undefined",
							"optional": true,
							"jsdoc": "A function that is called when the checkbox's checked state changes."
						},
						{
							"name": "render",
							"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
							"optional": true,
							"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
						},
						{
							"name": "value",
							"type": "string | number | readonly string[] | undefined",
							"optional": true,
							"jsdoc": "The value of the checkbox. This is useful when the same checkbox store is\nused for multiple [`Checkbox`](https://ariakit.org/reference/checkbox)\nelements, in which case the value will be an array of checked values."
						}
					],
					"baseElement": "input",
					"jsdoc": "A toggle switch element, typically used for enabling or disabling a feature.\n\nUse with the `Field` components to automatically handle ID associations for\nlabels and descriptions:\n```tsx\n<Field.Root>\n  <Field.Label>Enable feature</Field.Label>\n  <Field.Control render={<Switch />} />\n</Field.Root>\n```\n\nWithout the `Field` components you will need to manually associate labels,\ndescriptions, etc.:\n```tsx\n<Switch id=\"dark-mode\" />\n<Label htmlFor=\"dark-mode\">Dark mode</Label>\n```\n\nUnderneath, it's an HTML checkbox, i.e. `<input type=\"checkbox\">`, so it supports the same props,\nincluding `value`, `defaultChecked`, `checked`, and `onChange`.",
					"barrelName": "Switch"
				},
				"composition": [],
				"exportName": "Switch"
			},
			{
				"name": "Text",
				"convenience": {
					"name": "Text",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "variant",
							"type": "\"display-lg\" | \"display-md\" | \"display-sm\" | \"headline-lg\" | \"headline-md\" | \"headline-sm\" | \"body-lg\" | \"body-md\" | \"body-sm\" | \"caption-lg\" | \"caption-md\" | \"caption-sm\" | \"mono-sm\"",
							"optional": false,
							"jsdoc": "The typography variant to use."
						}
					],
					"baseElement": "div",
					"jsdoc": "An element with text styles applied. Useful for paragraphs, headings, and other text content.\n\nExample usage:\n```tsx\n<Text variant=\"display-sm\">Hello, World!</Text>\n```\n\nUse the `render` prop to change the underlying element (defaults to a `<div>`):\n```tsx\n<Text render={<h1 />} variant=\"headline-lg\">Hello, World!</Text>\n```",
					"barrelName": "Text"
				},
				"composition": [],
				"exportName": "Text"
			},
			{
				"name": "TextBox",
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "Compound component for a text input. Allows adding additional decorations.\n\nExample usage to add an end icon:\n```tsx\n<TextBox.Root>\n  <TextBox.Input defaultValue=\"Hello\" />\n  <TextBox.Icon href={...} />\n</TextBox.Root>\n```\n\nUse with the `Field` components to automatically handle ID associations for\nlabels and descriptions:\n```tsx\n<Field.Root>\n  <Field.Label>First name</Field.Label>\n  <Field.Control\n    render={(controlProps) => (\n      <TextBox.Root>\n        <TextBox.Input name=\"firstName\" {...controlProps} />\n        <TextBox.Icon href={…} />\n      </TextBox.Root>\n    )}\n  />\n</Field.Root>\n```",
						"barrelName": "TextBox.Root"
					},
					{
						"name": "Input",
						"baseProps": [],
						"props": [
							{
								"name": "accessibleWhenDisabled",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Indicates whether the element should be focusable even when it is\n[`disabled`](https://ariakit.org/reference/focusable#disabled).\n\nThis is important when discoverability is a concern. For example:\n\n> A toolbar in an editor contains a set of special smart paste functions\nthat are disabled when the clipboard is empty or when the function is not\napplicable to the current content of the clipboard. It could be helpful to\nkeep the disabled buttons focusable if the ability to discover their\nfunctionality is primarily via their presence on the toolbar.\n\nLearn more on [Focusability of disabled\ncontrols](https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#focusabilityofdisabledcontrols)."
							},
							{
								"name": "autoFocus",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Automatically focuses the element upon mounting, similar to the native\n`autoFocus` prop. This addresses an issue where the element with the native\n`autoFocus` attribute might receive focus before React effects are\nexecuted.\n\nThe `autoFocus` prop can also be used with\n[Focusable](https://ariakit.org/components/focusable) elements within a\n[Dialog](https://ariakit.org/components/dialog) component, establishing the\ninitial focus as the dialog opens.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
								"defaultValue": "false"
							},
							{
								"name": "children",
								"type": "undefined",
								"optional": true,
								"jsdoc": "Input is a [void element](https://developer.mozilla.org/en-US/docs/Glossary/Void_element) and no content is permitted."
							},
							{
								"name": "disabled",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Determines if the element is disabled. This sets the `aria-disabled`\nattribute accordingly, enabling support for all elements, including those\nthat don't support the native `disabled` attribute.\n\nThis feature can be combined with the\n[`accessibleWhenDisabled`](https://ariakit.org/reference/focusable#accessiblewhendisabled)\nprop to make disabled elements still accessible via keyboard.\n\n**Note**: For this prop to work, the\n[`focusable`](https://ariakit.org/reference/command#focusable) prop must be\nset to `true`, if it's not set by default.",
								"defaultValue": "false"
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							},
							{
								"name": "type",
								"type": "any",
								"optional": true,
								"jsdoc": "Describes a text based [input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types)\nbased on the value type the user will enter.",
								"defaultValue": "\"text\""
							}
						],
						"baseElement": "input",
						"jsdoc": "An input component that allows users to enter text based values.\n\nExample usage:\n```tsx\n<TextBox.Input name=\"greeting\" defaultValue=\"Hello\" />\n```\n\nTo add additional decorations, see `TextBox.Root` component.\n\nUse with the `Field` components to automatically handle ID associations for\nlabels and descriptions:\n```tsx\n<Field.Root>\n  <Field.Label>First name</Field.Label>\n  <Field.Control render={<TextBox.Input name=\"firstName\" />} />\n</Field.Root>\n```\n\nWithout the `Field` components you will need to manually associate labels,\ndescriptions, etc.:\n```tsx\n<Label htmlFor=\"fruit\">Fruit</Label>\n<TextBox.Input id=\"fruit\" aria-describedby=\"fruit-description\" />\n<Description id=\"fruit-description\">Something to include in a fruit salad.</Description>\n```\n\nUnderneath, it's an HTML input, i.e. `<input>`, so it supports the same props, including\n`value`, `defaultValue`, `onChange`, and `disabled`.\n\nFor a multiline text input, use the `TextBox.Textarea` component.",
						"barrelName": "TextBox.Input"
					},
					{
						"name": "Textarea",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [],
						"baseElement": "textarea",
						"jsdoc": "A styled textarea element that allows users to enter multiline text values.\n\nExample usage:\n```tsx\n<TextBox.Textarea defaultValue=\"Hello\" />\n```\n\nUse with the `Field` components to automatically handle ID associations for\nlabels and descriptions:\n```tsx\n<Field.Root>\n  <Field.Label>Leave a comment, be kind</Field.Label>\n  <Field.Control render={<TextBox.Textarea name=\"comment\" />} />\n</Field.Root>\n```\n\nWithout the `Field` components you will need to manually associate labels,\ndescriptions, etc.:\n```tsx\n<Label htmlFor=\"fruit\">Fruit</Label>\n<TextBox.Input id=\"fruit\" aria-describedby=\"fruit-description\" />\n<Description id=\"fruit-description\">Something to include in a fruit salad.</Description>\n```\n\nUnderneath, it's an HTML textarea, i.e. `<textarea>`, so it supports the same props, including\n`value`, `defaultValue`, `onChange`, and `disabled`.",
						"barrelName": "TextBox.Textarea"
					},
					{
						"name": "Icon",
						"baseProps": [],
						"props": [
							{
								"name": "alt",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Alternative text describing the icon.\n\nWhen this prop is passed, the SVG gets rendered as `role=\"img\"` and labelled\nusing the provided text.\n\nThis prop is not required if the icon is purely decorative. By default, the icon\nwill be hidden from the accessibility tree."
							},
							{
								"name": "href",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "URL of the `.svg` file (e.g. from `@stratakit/icons`).\n\nThe URL can contain a hash pointing to a specific symbol within the SVG (e.g. `#icon`, `#icon-large`).\nBy default, the `#icon` symbol is used if no hash is provided.\n\nNote: The `.svg` must be an external HTTP resource for it to be processed by\nthe `<use>` element. As a fallback, JS will be used to `fetch` the SVG from\nnon-supported URLs; the fetched SVG content will be sanitized using the\n`unstable_htmlSanitizer` function passed to `<Root>`."
							},
							{
								"name": "key",
								"type": "Key | null | undefined",
								"optional": true
							},
							{
								"name": "ref",
								"type": "Ref<HTMLElement | SVGSVGElement> | undefined",
								"optional": true,
								"jsdoc": "Allows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref)."
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							},
							{
								"name": "size",
								"type": "\"large\" | \"regular\" | undefined",
								"optional": true,
								"jsdoc": "Size of the icon. This only affects the icon's physical dimensions (not the SVG contents).\n\nDefaults to `\"regular\"` (16px) and can be optionally set to `\"large\"` (24px)."
							}
						],
						"baseElement": "svg",
						"jsdoc": "A static icon decoration for the `TextBox.Root` component. Can be added before or after the `TextBox.Input`.",
						"barrelName": "TextBox.Icon"
					},
					{
						"name": "Text",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "span",
						"jsdoc": "A static text decoration for the `TextBox.Root` component. Can be added before or after the `TextBox.Input`.",
						"barrelName": "TextBox.Text"
					}
				],
				"exportName": "TextBox"
			},
			{
				"name": "Tooltip",
				"convenience": {
					"name": "Tooltip",
					"baseProps": [
						"FocusableProps.render",
						"FocusableProps.autoFocus",
						"FocusableProps.disabled",
						"FocusableProps.accessibleWhenDisabled"
					],
					"props": [
						{
							"name": "children",
							"type": "ReactElement<unknown, string | JSXElementConstructor<any>>",
							"optional": false,
							"jsdoc": "The element that will trigger the tooltip when hovered or focused.\nCommon examples include buttons, links, or form controls.\n\n**Note**: The trigger must be a single interactive element. Do not add a\ntooltip to a non-interactive static element (such as a `<div>` or `<svg>`). Also,\nthe trigger element must forward its ref and spread its props."
						},
						{
							"name": "content",
							"type": "ReactNode",
							"optional": false,
							"jsdoc": "The content to be displayed inside the tooltip when the trigger element is hovered or focused."
						},
						{
							"name": "defaultOpen",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Whether the content should be visible by default.",
							"defaultValue": "false"
						},
						{
							"name": "open",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Controls the open state of the dialog. This is similar to the\n[`open`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/open)\nattribute on native dialog elements."
						},
						{
							"name": "placement",
							"type": "Placement | undefined",
							"optional": true,
							"jsdoc": "The placement of the tooltip.\n\nWhen not enough space is available to satisfy the specified placement, the tooltip will\nautomatically flip to the opposite side."
						},
						{
							"name": "setOpen",
							"type": "((open: boolean) => void) | undefined",
							"optional": true,
							"jsdoc": "A callback that gets called when the\n[`open`](https://ariakit.org/reference/disclosure-provider#open) state\nchanges."
						},
						{
							"name": "type",
							"type": "\"label\" | \"description\" | \"none\" | undefined",
							"optional": true,
							"jsdoc": "Determines how ARIA attributes are applied to the tooltip for accessibility:\n\n- `\"description\"`: The tooltip provides additional information via `aria-describedby`.\n- `\"label\"`: The tooltip acts as a label for the trigger element via `aria-labelledby`.\n- `\"none\"`: No ARIA attributes are applied; the tooltip is only for visual assistance.",
							"defaultValue": "\"description\""
						},
						{
							"name": "unmountOnHide",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "When set to `true`, the content element will be unmounted and removed from\nthe DOM when it's hidden.",
							"defaultValue": "false"
						}
					],
					"baseElement": "div",
					"jsdoc": "A tooltip component that provides additional information or context for an interactive trigger element.\n\nExample usage:\n\n```tsx\n<Tooltip content=\"This is a tooltip\">\n  <button>Hover over me</button>\n</Tooltip>\n```\n\n**Note**: The trigger element must be a single interactive element, such as a button or link. Do not add a\ntooltip to a non-interactive static element (such as a `<div>` or `<svg>`).\n\n**Note**: If `type` is set to `\"none\"`, the tooltip will not use ARIA attributes.",
					"barrelName": "Tooltip"
				},
				"composition": [],
				"exportName": "Tooltip"
			},
			{
				"name": "VisuallyHidden",
				"convenience": {
					"name": "VisuallyHidden",
					"baseProps": ["BaseProps.render"],
					"props": [],
					"baseElement": "span",
					"jsdoc": "A visually hidden element that is still accessible to screen readers and other assistive technology.\n\nThis is useful when you want to provide a text alternative to a visual element (e.g. an icon or symbol).\n\nExample:\n```tsx\n<span aria-hidden=\"true\">⭐</span>\n<VisuallyHidden>Favorite</VisuallyHidden>\n```\n\n**Note**: The `IconButton` component utilizes `VisuallyHidden` internally when the `label` prop is set.",
					"barrelName": "VisuallyHidden"
				},
				"composition": [],
				"exportName": "VisuallyHidden"
			}
		]
	},
	{
		"name": "structures",
		"apis": [
			{
				"name": "AccordionItem",
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "defaultOpen",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "The accordion item’s initial open state.",
								"defaultValue": "false"
							},
							{
								"name": "open",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "The accordion item’s controlled open state.",
								"defaultValue": "false"
							},
							{
								"name": "setOpen",
								"type": "((open: boolean) => void) | undefined",
								"optional": true,
								"jsdoc": "Callback fired when the accordion item is opened.\n\nShould be used with the `open` prop."
							}
						],
						"baseElement": "div",
						"jsdoc": "An item within an accordion. Disclosed content with a label.\n\nBare minimum example:\n```tsx\n<AccordionItem.Root>\n  <AccordionItem.Header>\n    <AccordionItem.Marker />\n    <AccordionItem.Button>\n      <AccordionItem.Label>Label</AccordionItem.Label>\n    </AccordionItem.Button>\n  </AccordionItem.Header>\n  <AccordionItem.Content>Body</AccordionItem.Content>\n</AccordionItem.Root>\n```\n\nIf the accordion item discloses a significant section of the page, it may be\ndesirable to markup its label as a heading for accessibility purposes (e.g.\nscreen reader users often navigate by heading). For those cases, you can wrap\nthe `AccordionItem.Button` component with an `AccordionItem.Heading`\ncomponent and use its `render` prop for rendering an HTML heading element.\n```tsx\n<AccordionItem.Root>\n  <AccordionItem.Header>\n    <AccordionItem.Marker />\n    <AccordionItem.Heading render={<h2 />}>\n      <AccordionItem.Button>\n        <AccordionItem.Label>Label</AccordionItem.Label>\n      </AccordionItem.Button>\n    </AccordionItem.Heading>\n  </AccordionItem.Header>\n  <AccordionItem.Content>Body</AccordionItem.Content>\n</AccordionItem.Root>\n```\n\nExample with a decoration:\n```tsx\n<AccordionItem.Root>\n  <AccordionItem.Header>\n    <AccordionItem.Marker />\n    <AccordionItem.Decoration render={<Icon href={placeholder} />} />\n    <AccordionItem.Button>\n      <AccordionItem.Label>Label</AccordionItem.Label>\n    </AccordionItem.Button>\n  </AccordionItem.Header>\n  <AccordionItem.Content>Body</AccordionItem.Content>\n</AccordionItem.Root>\n```",
						"barrelName": "unstable_AccordionItem.Root"
					},
					{
						"name": "Content",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The disclosed content of the accordion item.\n\nExample:\n```tsx\n<AccordionItem.Root>\n  <AccordionItem.Header>\n    <AccordionItem.Marker />\n    <AccordionItem.Button>\n      <AccordionItem.Label>Label</AccordionItem.Label>\n    </AccordionItem.Button>\n  </AccordionItem.Header>\n  <AccordionItem.Content>Body</AccordionItem.Content>\n</AccordionItem.Root>\n```",
						"barrelName": "unstable_AccordionItem.Content"
					},
					{
						"name": "Header",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The always visible header of an accordion item.\n\nMust include an `AccordionItem.Button` and `AccordionItem.Marker` as a direct\ndescendants.\n\nExample:\n```tsx\n<AccordionItem.Root>\n  <AccordionItem.Header>\n    <AccordionItem.Marker />\n    <AccordionItem.Button>\n      <AccordionItem.Label>Label</AccordionItem.Label>\n    </AccordionItem.Button>\n  </AccordionItem.Header>\n  <AccordionItem.Content>Body</AccordionItem.Content>\n</AccordionItem.Root>\n```",
						"barrelName": "unstable_AccordionItem.Header"
					},
					{
						"name": "Button",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "button",
						"jsdoc": "The accordion item button.\n\nMust be a direct descendant of `AccordionItem.Header`.\n\nExample:\n```tsx\n<AccordionItem.Header>\n  <AccordionItem.Marker />\n  <AccordionItem.Button>\n    <AccordionItem.Label>Label</AccordionItem.Label>\n  </AccordionItem.Button>\n</AccordionItem.Header>\n```",
						"barrelName": "unstable_AccordionItem.Button"
					},
					{
						"name": "Label",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "An accordion item’s label.\n\nMust be a descendant of `AccordionItem.Button`.\n\nExample:\n```tsx\n<AccordionItem.Button>\n  <AccordionItem.Label>Label</AccordionItem.Label>\n</AccordionItem.Button>\n```",
						"barrelName": "unstable_AccordionItem.Label"
					},
					{
						"name": "Decoration",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The always-visible, optional decoration of the `AccordionItem.Header` content.\nIt can be placed before or after the rest of the content in\n`AccordionItem.Header`. However, the `AccordionItem.Marker` must always be\nplaced at either edge (beginning or end) of the header.\n\nUse as a direct descendant of `AccordionItem.Header`. The decoration\ncan be placed before the rest of the header content.\n\nExample:\n```tsx\n<AccordionItem.Header>\n  <AccordionItem.Marker />\n  <AccordionItem.Decoration render={<Icon href={placeholder} />} />\n  <AccordionItem.Button>\n    <AccordionItem.Label>Label</AccordionItem.Label>\n  </AccordionItem.Button>\n</AccordionItem.Header>\n```\n\nAlternatively, the decoration can also be placed after the rest of the\nheader content.\n\nExample:\n```tsx\n<AccordionItem.Header>\n  <AccordionItem.Marker />\n  <AccordionItem.Button>\n    <AccordionItem.Label>Label</AccordionItem.Label>\n  </AccordionItem.Button>\n  <AccordionItem.Decoration render={<Icon href={placeholder} />} />\n</AccordionItem.Header>\n```\n\nThere can also be multiple decorations if passed as children under\n`AccordionItem.Decoration`.\n\nExample:\n```tsx\n<AccordionItem.Header>\n  <AccordionItem.Marker />\n  <AccordionItem.Decoration>\n    <Icon href={placeholder} />\n    <Icon href={placeholder} />\n  </AccordionItem.Decoration>\n  <AccordionItem.Button>\n    <AccordionItem.Label>Label</AccordionItem.Label>\n  </AccordionItem.Button>\n</AccordionItem.Header>\n```",
						"barrelName": "unstable_AccordionItem.Decoration"
					},
					{
						"name": "Marker",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The visual marker of the `AccordionItem.Header` content. While it can be\nplaced before or after the rest of the content in `AccordionItem.Header`,\nit is recommended to place the marker before.\n\nExample:\n```tsx\n<AccordionItem.Header>\n  <AccordionItem.Marker />\n  <AccordionItem.Button>\n    <AccordionItem.Label>Label</AccordionItem.Label>\n  </AccordionItem.Button>\n</AccordionItem.Header>\n```\n\nAlternatively, the marker can also be placed after the rest of the header\ncontent.\n\nExample:\n```tsx\n<AccordionItem.Header>\n  <AccordionItem.Button>\n    <AccordionItem.Label>Label</AccordionItem.Label>\n  </AccordionItem.Button>\n  <AccordionItem.Marker />\n</AccordionItem.Header>\n```\n\nPass an icon as a child to override the default chevron icon:\n```tsx\n<AccordionItem.Header>\n  <AccordionItem.Marker>\n    <Icon href={placeholder} />\n  </AccordionItem.Marker>\n  <AccordionItem.Button>\n    <AccordionItem.Label>Label</AccordionItem.Label>\n  </AccordionItem.Button>\n</AccordionItem.Header>\n```",
						"barrelName": "unstable_AccordionItem.Marker"
					},
					{
						"name": "Heading",
						"baseProps": [],
						"props": [
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement",
								"optional": false
							}
						],
						"baseElement": "div",
						"jsdoc": "A heading for wrapping `AccordionItem.Button`.\n\nThe `render` prop is required.\n\nExample:\n```tsx\n<AccordionItem.Header>\n  <AccordionItem.Marker />\n  <AccordionItem.Heading render={<h2 />}>\n    <AccordionItem.Button>\n      <AccordionItem.Label>Label</AccordionItem.Label>\n    </AccordionItem.Button>\n  </AccordionItem.Heading>\n</AccordionItem.Header>",
						"barrelName": "unstable_AccordionItem.Heading"
					}
				],
				"exportName": "unstable_AccordionItem"
			},
			{
				"name": "Banner",
				"convenience": {
					"name": "Banner",
					"baseProps": [],
					"props": [
						{
							"name": "label",
							"type": "string | Element",
							"optional": false,
							"jsdoc": "The label of the banner.\n\nEither pass a string or a `<VisuallyHidden>` component if you don't want the label to be visible."
						},
						{
							"name": "message",
							"type": "ReactNode",
							"optional": false,
							"jsdoc": "The message content of the banner."
						},
						{
							"name": "actions",
							"type": "ReactNode",
							"optional": true,
							"jsdoc": "The actions available for the banner.\n\nExample with one action:\n```tsx\nactions={<Button key={…} onClick={}>Action</Button>}\n```\n\nExample with two `Button`s:\n```tsx\nactions={\n  <>\n    <Button key={…} onClick={…}>Action 1</Button>,\n    <Button key={…} onClick={…}>Action 2</Button>,\n  </>\n}\n```\n\nExample with two `Anchor`s as `Button`:\n```tsx\nactions={\n  <>\n    <Anchor key={…} render={<button />} onClick={…}>Action 1</Anchor>,\n    <Anchor key={…} render={<button />} onClick={…}>Action 2</Anchor>,\n  </>\n}\n```"
						},
						{
							"name": "icon",
							"type": "string | Element | undefined",
							"optional": true,
							"jsdoc": "A static icon decoration for the banner.\n\nCan be a URL of an SVG from the `@stratakit/icons` package, or a custom JSX icon.\n\n- If no `icon` is passed and the `tone` is `\"neutral\"`, no icon is shown.\n- If no `icon` is passed and the `tone` is not `\"neutral\"`, the status icon is shown."
						},
						{
							"name": "onDismiss",
							"type": "(() => void) | undefined",
							"optional": true,
							"jsdoc": "Callback invoked when the dismiss (\"❌\") button is clicked.\n\nIf `undefined`, the dismiss button will not be rendered.",
							"defaultValue": "undefined"
						},
						{
							"name": "render",
							"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
							"optional": true,
							"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
						},
						{
							"name": "tone",
							"type": "\"neutral\" | \"info\" | \"positive\" | \"attention\" | \"critical\" | undefined",
							"optional": true,
							"jsdoc": "The tone of the banner.",
							"defaultValue": "\"neutral\""
						},
						{
							"name": "variant",
							"type": "\"outline\" | undefined",
							"optional": true,
							"jsdoc": "The variant of the banner.",
							"defaultValue": "\"outline\""
						}
					],
					"baseElement": "div",
					"jsdoc": "A banner to highlight information and also optionally provide actions.\nThe information could be very important (like a call to action) or reasonably import (like a status message).\n\nExample:\n```tsx\n<Banner label=\"Label\" message=\"Message\" icon={placeholderIcon} onDismiss={() => {}} />\n```",
					"barrelName": "unstable_Banner"
				},
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "tone",
								"type": "\"neutral\" | \"info\" | \"positive\" | \"attention\" | \"critical\" | undefined",
								"optional": true,
								"jsdoc": "The tone of the banner.",
								"defaultValue": "\"neutral\""
							},
							{
								"name": "variant",
								"type": "\"outline\" | undefined",
								"optional": true,
								"jsdoc": "The variant of the banner.",
								"defaultValue": "\"outline\""
							}
						],
						"baseElement": "div",
						"jsdoc": "A banner to highlight information and also optionally provide actions.\nThe information could be very important (like a call to action) or reasonably import (like a status message).\n\nExample:\n```tsx\n<Banner.Root tone=\"info\" variant=\"outline\">\n  <Banner.Icon />\n  <Banner.Label>Label</Banner.Label>\n  <Banner.Message>Message</Banner.Message>\n  <Banner.DismissButton onClick={onDismiss} />\n</Banner.Root>\n```"
					},
					{
						"name": "Icon",
						"baseProps": [],
						"props": [
							{
								"name": "alt",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Alternative text describing the icon.\n\nWhen this prop is passed, the SVG gets rendered as `role=\"img\"` and labelled\nusing the provided text.\n\nThis prop is not required if the icon is purely decorative. By default, the icon\nwill be hidden from the accessibility tree."
							},
							{
								"name": "href",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "URL of the `.svg` file (e.g. from `@stratakit/icons`).\n\nThe URL can contain a hash pointing to a specific symbol within the SVG (e.g. `#icon`, `#icon-large`).\nBy default, the `#icon` symbol is used if no hash is provided.\n\nNote: The `.svg` must be an external HTTP resource for it to be processed by\nthe `<use>` element. As a fallback, JS will be used to `fetch` the SVG from\nnon-supported URLs; the fetched SVG content will be sanitized using the\n`unstable_htmlSanitizer` function passed to `<Root>`."
							},
							{
								"name": "key",
								"type": "Key | null | undefined",
								"optional": true
							},
							{
								"name": "ref",
								"type": "Ref<HTMLElement | SVGSVGElement> | undefined",
								"optional": true,
								"jsdoc": "Allows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref)."
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							},
							{
								"name": "size",
								"type": "\"regular\" | \"large\" | undefined",
								"optional": true,
								"jsdoc": "Size of the icon. This only affects the icon's physical dimensions (not the SVG contents).\n\nDefaults to `\"regular\"` (16px) and can be optionally set to `\"large\"` (24px)."
							}
						],
						"baseElement": "svg",
						"jsdoc": "A static icon decoration for the banner.\n\n- If no `href` is passed and the `tone` is `\"neutral\"`, no icon is shown.\n- If no `href` is passed and the `tone` is not` \"neutral\"`, the status icon is shown.\n\nExample with default status icon:\n```tsx\n<Banner.Root tone=\"info\">\n  <Banner.Icon />\n</Banner.Root>\n\nExample with custom icon:\n```tsx\nimport placeholderIcon from \"@stratakit/icons/placeholder.svg\";\n\n<Banner.Root>\n  <Banner.Icon href={placeholderIcon} />\n</Banner.Root>\n```"
					},
					{
						"name": "Label",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "span",
						"jsdoc": "The label of the banner.\n\nPass `render={<VisuallyHidden />}` if you don't want the label to be visible.\n\nExample:\n```tsx\n<Banner.Root>\n  <Banner.Label>Label</Banner.Label>\n</Banner.Root>\n```\n\nExample with a visually hidden label:\n```tsx\n<Banner.Root>\n  <Banner.Label render={<VisuallyHidden />}>Label</Banner.Label>\n</Banner.Root>\n```"
					},
					{
						"name": "Message",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "span",
						"jsdoc": "The message content of the banner.\n\nExample:\n```tsx\n<Banner.Root>\n  <Banner.Message>Message content goes here.</Banner.Message>\n</Banner.Root>\n```"
					},
					{
						"name": "Actions",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The actions available for the banner.\n\nExample with one action:\n```tsx\n<Banner.Root>\n  <Banner.Actions>\n    <Button key={…} onClick={…}>Action</Button>\n  </Banner.Actions>\n</Banner.Root>\n```\n\nExample with two `Button`s:\n```tsx\n<Banner.Root>\n  <Banner.Actions>\n    <Button key={…} onClick={…}>Action 1</Button>\n    <Button key={…} onClick={…}>Action 2</Button>\n  </Banner.Actions>\n</Banner.Root>\n```\n\nExample with two `Anchor`s as `Button`:\n```tsx\n<Banner.Root>\n  <Banner.Actions>\n    <Anchor key={…} render={<button />} onClick={…}>Action 1</Anchor>,\n    <Anchor key={…} render={<button />} onClick={…}>Action 2</Anchor>,\n  </Banner.Actions>\n</Banner.Root>\n```"
					},
					{
						"name": "DismissButton",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "label",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Label for the dismiss button.\n\nThe final accessible name of the dismiss button is a combination of this `label` and the text content of `Banner.Label`.",
								"defaultValue": "\"Dismiss\""
							}
						],
						"baseElement": "button",
						"jsdoc": "Dismiss (\"❌\") button for the banner.\nHandle the `onClick` callback to dismiss the banner.\n\nExample:\n```tsx\n<Banner.Root>\n  <Banner.DismissButton onClick={() => {}} />\n</Banner.Root>\n```"
					}
				],
				"exportName": "unstable_Banner"
			},
			{
				"name": "Chip",
				"convenience": {
					"name": "Chip",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "label",
							"type": "ReactNode",
							"optional": false,
							"jsdoc": "The label displayed inside the chip."
						},
						{
							"name": "onDismiss",
							"type": "(() => void) | undefined",
							"optional": true,
							"jsdoc": "Callback invoked when the dismiss (\"❌\") button is clicked.\n\nIf `undefined`, the dismiss button will not be rendered.",
							"defaultValue": "undefined"
						},
						{
							"name": "variant",
							"type": "\"outline\" | \"solid\" | undefined",
							"optional": true,
							"jsdoc": "The variant style of the Chip.\nUse \"solid\" for primary states and \"outline\" for less prominent states.",
							"defaultValue": "\"solid\""
						}
					],
					"baseElement": "div",
					"jsdoc": "Chip is a UI component used to represent an item, attribute, or action in a compact visual style.\nIt supports two visual variants: `solid` for primary emphasis and `outline` for less prominent states.\n\nExample:\n```tsx\n<Chip label=\"Value\" />\n<Chip label=\"Value\" variant=\"outline\" />\n```",
					"barrelName": "Chip"
				},
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "variant",
								"type": "\"outline\" | \"solid\" | undefined",
								"optional": true,
								"jsdoc": "The variant style of the Chip.\nUse \"solid\" for primary states and \"outline\" for less prominent states.",
								"defaultValue": "\"solid\""
							}
						],
						"baseElement": "div",
						"jsdoc": "Root component of the compositional Chip component.\n\nExample:\n```tsx\n<Chip.Root>\n  <Chip.Label>Label</Chip.Label>\n  <Chip.DismissButton onClick={onClick} />\n</Chip.Root>\n```"
					},
					{
						"name": "Label",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "span",
						"jsdoc": "Label component that should be used with the compositional Chip component."
					},
					{
						"name": "DismissButton",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "label",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Label for the dismiss button.\n\nThe final accessible name of the dismiss button is a combination of this `label` and the text content of `Chip.Label`.",
								"defaultValue": "\"Dismiss\""
							}
						],
						"baseElement": "button",
						"jsdoc": "Dismiss button component that should be used with the compositional Chip component."
					}
				],
				"exportName": "Chip"
			},
			{
				"name": "Dialog",
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "modal",
								"type": "true",
								"optional": false,
								"jsdoc": "Determines whether the dialog is modal.\nCurrently, only modal dialogs are supported."
							},
							{
								"name": "backdrop",
								"type": "boolean | ReactElement<DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>, string | JSXElementConstructor<any>> | ElementType<...> | undefined",
								"optional": true,
								"jsdoc": "Determines whether there will be a backdrop behind the dialog. On modal\ndialogs, this is `true` by default. Besides a `boolean`, this prop can also\nbe a React component or JSX element that will be rendered as the backdrop.\n\n**Note**: If a custom component is used, it must [accept ref and spread all\nprops to its underlying DOM\nelement](https://ariakit.org/guide/composition#custom-components-must-be-open-for-extension),\nthe same way a native element would."
							},
							{
								"name": "hideOnInteractOutside",
								"type": "BooleanOrCallback<Event | SyntheticEvent<Element, Event>> | undefined",
								"optional": true,
								"jsdoc": "Determines if the dialog should hide when the user clicks or focuses on an\nelement outside the dialog.\n\nThis prop can be either a boolean or a function that takes an event as an\nargument and returns a boolean. The event object represents the event that\ntriggered the action, which could be a native event or a React synthetic\nevent of various types.",
								"defaultValue": "true"
							},
							{
								"name": "onClose",
								"type": "((event: Event) => void) | undefined",
								"optional": true,
								"jsdoc": "This is an event handler prop triggered when the dialog's `close` event is\ndispatched. The `close` event is similar to the native dialog\n[`close`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/close_event)\nevent. The only difference is that this event can be canceled with\n`event.preventDefault()`, which will prevent the dialog from hiding.\n\nIt's important to note that this event only fires when the dialog store's\n[`open`](https://ariakit.org/reference/use-dialog-store#open) state is set\nto `false`. If the controlled\n[`open`](https://ariakit.org/reference/dialog#open) prop value changes, or\nif the dialog's visibility is altered in any other way (such as unmounting\nthe dialog without adjusting the open state), this event won't be\ntriggered."
							},
							{
								"name": "open",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Controls the open state of the dialog. This is similar to the\n[`open`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/open)\nattribute on native dialog elements."
							},
							{
								"name": "unmountOnHide",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "When set to `true`, the content element will be unmounted and removed from\nthe DOM when it's hidden.",
								"defaultValue": "true"
							}
						],
						"baseElement": "div",
						"jsdoc": "A modal dialog component used to display content in a window overlay. Must include `Dialog.Header` and `Dialog.Content` as direct\ndescendants. Additionally, `Dialog.Footer` can be optionally used as a direct descendant.\n\nExample:\n```tsx\nconst [open, setOpen] = useState(false);\n\n<Dialog.Root modal={true} open={open} onClose={() => setOpen(false)}>\n  <Dialog.Heading>Heading</Dialog.Heading>\n  <Dialog.Content>Content</Dialog.Content>\n  <Dialog.Footer>\n    <Dialog.ActionList\n      actions={[\n        <Button key=\"ok\" onClick={() => setOpen(false)}>Ok</Button>,\n      ]}\n    />\n\n  </Dialog.Footer>\n</Dialog.Root>\n```",
						"barrelName": "unstable_Dialog.Root"
					},
					{
						"name": "Header",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The header of a dialog. Should be used as a child of `Dialog.Root`. Must include `Dialog.Heading` as a direct\ndescendant. Additionally, `Dialog.CloseButton` can be optionally used as a direct descendant.\n\nExample:\n```tsx\n<Dialog.Header>\n  <Dialog.Heading>Heading</Dialog.Heading>\n  <Dialog.CloseButton />\n</Dialog.Header>\n```\n\nUse `render` prop when only a heading is displayed in a header.\n\n```tsx\n<Dialog.Header render={<Dialog.Heading />}>Heading</Dialog.Header>\n```",
						"barrelName": "unstable_Dialog.Header"
					},
					{
						"name": "Heading",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "h1",
						"jsdoc": "The heading of a dialog. Should be used as a child of `Dialog.DialogHeader`.\n\nExample:\n```tsx\n<Dialog.Heading>Heading</Dialog.Heading>\n```",
						"barrelName": "unstable_Dialog.Heading"
					},
					{
						"name": "CloseButton",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [
							{
								"name": "label",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Label for the close button.",
								"defaultValue": "\"Dismiss\""
							}
						],
						"baseElement": "button",
						"jsdoc": "A button that closes the dialog. Displayed as an icon button in the top-right corner of the dialog.\nShould be used as a child of `Dialog.DialogHeader`.\n\nExample:\n```tsx\n<Dialog.CloseButton />\n```",
						"barrelName": "unstable_Dialog.CloseButton"
					},
					{
						"name": "Content",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The content of a dialog. Should be used as a child of `Dialog.Root`.\n\nExample:\n```tsx\n<Dialog.Content>Content</Dialog.Content>\n```",
						"barrelName": "unstable_Dialog.Content"
					},
					{
						"name": "Footer",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The footer section of a dialog, typically used to display action buttons at the bottom of the dialog.\nShould be used as a child of `Dialog.Root`. Use `Dialog.ActionList` as a direct descendant to display a list of actions.\n\nExample:\n```tsx\n<Dialog.Footer>\n  <Dialog.ActionList\n    actions={[\n      <Button key=\"cancel\" onClick={() => setOpen(false)}>Cancel</Button>,\n      <Button key=\"ok\" tone=\"accent\" onClick={() => setOpen(false)}>Ok</Button>,\n    ]}\n  />\n</Dialog.Footer>\n```",
						"barrelName": "unstable_Dialog.Footer"
					},
					{
						"name": "ActionList",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "actions",
								"type": "ReactNode[] | undefined",
								"optional": true,
								"jsdoc": "The actions available for the dialog. Must be a list of `Button` components."
							}
						],
						"baseElement": "div",
						"jsdoc": "A container for action buttons in a dialog. Should be used as a child of `Dialog.Footer`.\n\nExample:\n```tsx\n<Dialog.ActionList\n  actions={[\n    <Button key=\"cancel\" onClick={() => setOpen(false)}>Cancel</Button>,\n    <Button key=\"ok\" tone=\"accent\" onClick={() => setOpen(false)}>Ok</Button>,\n  ]}\n/>\n```",
						"barrelName": "unstable_Dialog.ActionList"
					},
					{
						"name": "Backdrop",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The backdrop of a dialog. Should be passed into the `backdrop` prop of `Dialog.Root`.\n\nExample:\n```tsx\n<Dialog.Root modal={true} backdrop={<Dialog.Backdrop />} />\n```",
						"barrelName": "unstable_Dialog.Backdrop"
					}
				],
				"exportName": "unstable_Dialog"
			},
			{
				"name": "DropdownMenu",
				"composition": [
					{
						"name": "Provider",
						"baseProps": [],
						"props": [
							{
								"name": "children",
								"type": "ReactNode",
								"optional": true
							},
							{
								"name": "defaultOpen",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Whether the content should be visible by default.",
								"defaultValue": "false"
							},
							{
								"name": "open",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Whether the content is visible.",
								"defaultValue": "false"
							},
							{
								"name": "placement",
								"type": "Placement | undefined",
								"optional": true,
								"defaultValue": "\"bottom-start\""
							},
							{
								"name": "setOpen",
								"type": "((open: boolean) => void) | undefined",
								"optional": true,
								"jsdoc": "A callback that gets called when the\n[`open`](https://ariakit.org/reference/disclosure-provider#open) state\nchanges."
							}
						],
						"jsdoc": "A dropdown menu displays a list of actions or commands when the menu button is clicked.\n\n`DropdownMenu` is a compound component with subcomponents exposed for different parts.\n\nExample:\n```tsx\n<DropdownMenu.Provider>\n  <DropdownMenu.Button>Actions</DropdownMenu.Button>\n\n  <DropdownMenu.Content>\n    <DropdownMenu.Item label=\"Add\" />\n    <DropdownMenu.Item label=\"Edit\" />\n    <DropdownMenu.Item label=\"Delete\" />\n  </DropdownMenu.Content>\n</DropdownMenu.Provider>\n```\n\n**Note**: `DropdownMenu` should not be used for navigation; it is only intended for actions.",
						"barrelName": "DropdownMenu.Provider"
					},
					{
						"name": "Button",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [],
						"baseElement": "button",
						"jsdoc": "The button that triggers the dropdown menu to open. Should be used as a child of `DropdownMenu.Provider`.\n\nExample:\n```tsx\n<DropdownMenu.Button>Actions</DropdownMenu.Button>\n```\n\nBy default it will render a solid `Button` with a disclosure arrow. This can be\ncustomized by passing a `render` prop.\n\n```tsx\n<DropdownMenu.Button\n  render={<IconButton variant=\"ghost\" label=\"More\" icon={<Icon href={…} />} />}\n/>\n```",
						"barrelName": "DropdownMenu.Button"
					},
					{
						"name": "Content",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The actual \"menu\" portion containing the items shown within the dropdown.\n\nShould be used as a child of `DropdownMenu.Provider`.\n\nShould include one or more of `DropdownMenu.Item`, `DropdownMenu.CheckboxItem` and `DropdownMenu.Group` as direct descendants.",
						"barrelName": "DropdownMenu.Content"
					},
					{
						"name": "Item",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [
							{
								"name": "label",
								"type": "ReactNode",
								"optional": false,
								"jsdoc": "The primary text label for the menu-item."
							},
							{
								"name": "icon",
								"type": "string | Element | undefined",
								"optional": true,
								"jsdoc": "An optional icon displayed before the menu-item label.\n\nCan be a URL of an SVG from the `@stratakit/icons` package,\nor a custom JSX icon."
							},
							{
								"name": "shortcuts",
								"type": "AnyString | `Control+${AnyString}` | `Shift+${AnyString}` | `Backspace+${AnyString}` | `Command+${AnyString}` | `Down+${AnyString}` | `Eject+${AnyString}` | ... 8 more ... | undefined",
								"optional": true,
								"jsdoc": "A string defining the keyboard shortcut(s) associated with the menu item.\n\n```tsx\nshortcuts=\"S\" // A single key shortcut\n```\n\nMultiple keys should be separated by the `+` character. If one of the keys is\nrecognized as a symbol name or a modifier key, it will be displayed as a symbol.\n\n```tsx\nshortcuts=\"Control+Enter\" // A multi-key shortcut, displayed as \"Ctrl ⏎\"\n```"
							},
							{
								"name": "submenu",
								"type": "ReactNode",
								"optional": true,
								"jsdoc": "The submenu to display when the item is activated. Must be a `DropdownMenu.Submenu` component."
							},
							{
								"name": "unstable_dot",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Dot shown on the right end of the menu-item. Value will be used as accessible description."
							}
						],
						"baseElement": "button",
						"jsdoc": "A single menu item within the dropdown menu. Should be used as a child of `DropdownMenu.Content` and `DropdownMenu.Submenu`.\n\nExample:\n```tsx\n<DropdownMenu.Item label=\"Add\" />\n<DropdownMenu.Item label=\"Edit\" />\n```\n\nUse the `submenu` prop to display a submenu.\n\nExample:\n```tsx\n<DropdownMenu.Item\n  label=\"More\"\n  submenu={\n    <DropdownMenu.Submenu>\n      <DropdownMenu.Item label=\"Add\" />\n      <DropdownMenu.Item label=\"Edit\" />\n    </DropdownMenu.Submenu>\n  }\n/>\n```",
						"barrelName": "DropdownMenu.Item"
					},
					{
						"name": "CheckboxItem",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [
							{
								"name": "label",
								"type": "ReactNode",
								"optional": false,
								"jsdoc": "The primary text label for the menu-item."
							},
							{
								"name": "name",
								"type": "string",
								"optional": false,
								"jsdoc": "The name of the field in the\n[`values`](https://ariakit.org/reference/menu-provider#values) state."
							},
							{
								"name": "checked",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "The controlled checked state of the element. It will set the menu\n[`values`](https://ariakit.org/reference/menu-provider#values) state if\nprovided."
							},
							{
								"name": "defaultChecked",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "The default checked state of the element. It will set the default value in\nthe menu [`values`](https://ariakit.org/reference/menu-provider#values)\nstate if provided."
							},
							{
								"name": "icon",
								"type": "string | Element | undefined",
								"optional": true,
								"jsdoc": "An optional icon displayed before the menu-item label.\n\nCan be a URL of an SVG from the `@stratakit/icons` package,\nor a custom JSX icon."
							},
							{
								"name": "onChange",
								"type": "ChangeEventHandler<HTMLInputElement> | undefined",
								"optional": true,
								"jsdoc": "A function that is called when the checkbox's checked state changes."
							},
							{
								"name": "value",
								"type": "string | number | readonly string[] | undefined",
								"optional": true,
								"jsdoc": "The value of the checkbox. This is useful when the same checkbox store is\nused for multiple [`Checkbox`](https://ariakit.org/reference/checkbox)\nelements, in which case the value will be an array of checked values."
							}
						],
						"baseElement": "button",
						"jsdoc": "A single checkbox menu item within the dropdown menu. Should be used as a child of `DropdownMenu.Content` and `DropdownMenu.Submenu`.\n\nExample:\n```tsx\n<DropdownMenu.CheckboxItem name=\"add\" label=\"Add\" />\n<DropdownMenu.CheckboxItem name=\"edit\" label=\"Edit\" />\n```",
						"barrelName": "DropdownMenu.CheckboxItem"
					},
					{
						"name": "Submenu",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The submenu portion containing the nested submenu items.\n\nShould be passed into the `submenu` prop of `DropdownMenu.Item`.\n\nShould include one or more of `DropdownMenu.Item`, `DropdownMenu.CheckboxItem` and `DropdownMenu.Group` as direct descendants.",
						"barrelName": "DropdownMenu.Submenu"
					},
					{
						"name": "Group",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "items",
								"type": "Element[]",
								"optional": false,
								"jsdoc": "The menu items within the group.\n\nShould be an array of `DropdownMenu.Item` and/or `DropdownMenu.CheckboxItem` elements."
							},
							{
								"name": "label",
								"type": "string",
								"optional": false,
								"jsdoc": "The text label for the menu-group."
							}
						],
						"baseElement": "div",
						"jsdoc": "A group of menu items within the dropdown menu. Should be used as a child of `DropdownMenu.Content` and `DropdownMenu.Submenu`.\n\nExample:\n```tsx\n<DropdownMenu.Group\n\tlabel=\"Manage\"\n\titems={[\n  <DropdownMenu.Item key=\"add\" label=\"Add\" />,\n  <DropdownMenu.Item key=\"edit\" label=\"Edit\" />\n\t]}\n/>\n```",
						"barrelName": "DropdownMenu.Group"
					}
				],
				"exportName": "DropdownMenu"
			},
			{
				"name": "ErrorRegion",
				"composition": [
					{
						"name": "Root",
						"baseProps": [],
						"props": [
							{
								"name": "items",
								"type": "ReactNode[] | undefined",
								"optional": true,
								"jsdoc": "A list of error items where each item describes an individual error. Must be a list of `ErrorRegion.Item` components.\n\nSet to `undefined` or empty array if you don't want to display errors rather than conditionally rendering the component."
							},
							{
								"name": "label",
								"type": "ReactNode",
								"optional": true,
								"jsdoc": "Label for the error header, usually indicating the number of errors displayed.\n\nChanges to the `label` prop will be communicated\nusing a [live region](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Guides/Live_regions)."
							},
							{
								"name": "open",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "The controlled open state of the region."
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							},
							{
								"name": "setOpen",
								"type": "((open: boolean) => void) | undefined",
								"optional": true,
								"jsdoc": "Callback fired when the region is open.\n\nShould be used with the `open` prop."
							}
						],
						"baseElement": "div",
						"jsdoc": "A collapsible region that displays a list of error messages, which might originate from another\ncomponent, such as `Tree`.\n\nThis component is rendered as a [region landmark](https://www.w3.org/WAI/ARIA/apg/patterns/landmarks/examples/region.html)\nand should be labelled using `aria-label` or `aria-labelledby`.\n\nThis component should not be rendered conditionally, instead use the `items` prop to control the visibility.\n\nExample:\n```tsx\n<ErrorRegion.Root\n  aria-label=\"Issues\"\n  label=\"3 issues found\"\n  items={[\n    <ErrorRegion.Item key={…} message=\"…\" />\n    <ErrorRegion.Item key={…} message=\"…\" />\n    <ErrorRegion.Item key={…} message=\"…\" />\n  ]}\n/>",
						"barrelName": "unstable_ErrorRegion.Root"
					},
					{
						"name": "Item",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "actions",
								"type": "ReactNode",
								"optional": true,
								"jsdoc": "The actions available for this item. Must be a list of anchors, each rendered as a button using `<Anchor render={<button />} />`."
							},
							{
								"name": "message",
								"type": "ReactNode",
								"optional": true,
								"jsdoc": "The error message. Consumers might consider using `Anchor` component to link to the associated element in the UI."
							},
							{
								"name": "messageId",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "The `id` of the message node which can be used to semantically associate the error item with the related UI item i.e. `Tree.Item`."
							}
						],
						"baseElement": "div",
						"jsdoc": "An individual error item within the `ErrorRegion` component. It displays an error message and optional actions.\n\nThe `messageId` prop can be used to semantically associate the error item with the related UI item, such as a `Tree.Item`.\n\nExample:\n```tsx\n<ErrorRegion.Item\n  message={<>Something went wrong with <Anchor href=\"item-10001\">Item 10001</Anchor>.</>}\n  messageId=\"item-10001-error\"\n  actions={<Button>Retry</Button>}\n/>\n\n<Tree.Item\n  id=\"item-10001\"\n  label=\"Item 10001\"\n  error=\"item-10001-error\"\n/>\n```",
						"barrelName": "unstable_ErrorRegion.Item"
					}
				],
				"exportName": "unstable_ErrorRegion"
			},
			{
				"name": "NavigationList",
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "items",
								"type": "Element[]",
								"optional": false,
								"jsdoc": "The navigation items to render within the list.\nShould be an array of `NavigationList.Anchor` elements."
							}
						],
						"baseElement": "div",
						"jsdoc": "A navigation list displays a collection of navigation links, one of which can be \"active\".\n\nBasic example:\n```tsx\n<NavigationList.Root\n  items={[\n    <NavigationList.Anchor key={1} href=\"/page1\" label=\"Item 1\" />,\n    <NavigationList.Anchor key={2} href=\"/page2\" label=\"Item 2\" active />,\n  ]}\n/>\n```\n\nExample with subgroups:\n```tsx\n<NavigationList.Root\n  items={[\n    <NavigationList.Anchor key={1} href=\"/page1\" label=\"Item 1\" />,\n    <NavigationList.Anchor key={2} href=\"/page2\" label=\"Item 2\" />,\n    <NavigationList.Subgroup\n      key={3}\n      label=\"Subgroup\"\n      items={[\n        <NavigationList.Anchor key={1} href=\"/page3-1\" label=\"Item 3.1\" />,\n        <NavigationList.Anchor key={2} href=\"/page3-2\" label=\"Item 3.2\" />,\n      ]}\n    />,\n  ]}\n/>\n```",
						"barrelName": "unstable_NavigationList.Root"
					},
					{
						"name": "Anchor",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [
							{
								"name": "label",
								"type": "string",
								"optional": false,
								"jsdoc": "The label of the navigation anchor."
							},
							{
								"name": "active",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Whether the anchor is active.\n\nThis will automatically set `aria-current=\"true\"` on the anchor."
							},
							{
								"name": "icon",
								"type": "string | Element | undefined",
								"optional": true,
								"jsdoc": "The icon shown before the label of the navigation anchor.\n\nCan be a URL of an SVG from the `@stratakit/icons` package,\nor a custom JSX icon."
							}
						],
						"baseElement": "a",
						"jsdoc": "An individual anchor within the navigation list. This should perform a navigation\nto a different view, page or section. (Make sure to use proper routing/navigation)\n\nShould be used as an element within the `items` array of `NavigationList.Root`.\n\nExample:\n```tsx\n<NavigationList.Anchor href=\"/profile\"> label=\"Profile\" />\n```",
						"barrelName": "unstable_NavigationList.Anchor"
					},
					{
						"name": "Subgroup",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "items",
								"type": "Element[]",
								"optional": false,
								"jsdoc": "The navigation items within the subgroup.\nShould be an array of `NavigationList.Anchor` elements."
							},
							{
								"name": "label",
								"type": "string",
								"optional": false,
								"jsdoc": "The label for the subgroup."
							},
							{
								"name": "defaultOpen",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Whether the subgroup is expanded by default."
							},
							{
								"name": "icon",
								"type": "string | Element | undefined",
								"optional": true,
								"jsdoc": "The icon shown before the label of the subgroup.\n\nCan be a URL of an SVG from the `@stratakit/icons` package,\nor a custom JSX icon."
							}
						],
						"baseElement": "div",
						"jsdoc": "A subgroup within the navigation list, used to group related navigation items.\n\nShould be used as an element within the `items` array of `NavigationList.Root`.\n\nExample:\n```tsx\n<NavigationList.Subgroup label=\"Management\" items={[ … ]} />\n```",
						"barrelName": "unstable_NavigationList.Subgroup"
					}
				],
				"exportName": "unstable_NavigationList"
			},
			{
				"name": "NavigationRail",
				"composition": [
					{
						"name": "Root",
						"baseProps": [],
						"props": [
							{
								"name": "defaultExpanded",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "The initial expanded state of the `NavigationRail` when it is first rendered.\n\nThis prop is recommended over `expanded` when you don't need to fully control the expanded\nstate from the outside.\n\nThis prop will be ignored if the `expanded` prop is provided.",
								"defaultValue": "false"
							},
							{
								"name": "expanded",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Control whether the `NavigationRail` is expanded or collapsed.\n\nWhen `true`, the `NavigationRail` shows both icons and labels for its items.\nWhen `false`, it shows only icons, with labels available as tooltips.\n\nThis prop is optional; if not provided, the `NavigationRail` will manage its own state internally.\n\nThis should be used in conjunction with the `setExpanded` prop to reflect internal state changes."
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							},
							{
								"name": "setExpanded",
								"type": "((expanded: boolean) => void) | undefined",
								"optional": true,
								"jsdoc": "Callback that is called when the expanded state of the `NavigationRail` changes.\n\nThis is useful for syncing the internal state of the `NavigationRail` with external state."
							}
						],
						"baseElement": "nav",
						"jsdoc": "The `NavigationRail` presents top-level navigation items in a vertical orientation.\n\nExample:\n```tsx\n<NavigationRail.Root>\n  <NavigationRail.Header>\n    <IconButton label=\"Home\" icon={applicationIcon} href=\"/\" />\n    <NavigationRail.ToggleButton />\n  </NavigationRail.Header>\n\n  <NavigationRail.Content>\n    <NavigationRail.List>\n      <NavigationRail.ListItem>\n        <NavigationRail.Anchor label=\"Dashboard\" icon={dashboardIcon} href=\"/dashboard\" />\n      </NavigationRail.ListItem>\n      <NavigationRail.ListItem>\n        <NavigationRail.Anchor label=\"Projects\" icon={projectsIcon} href=\"/projects\" />\n      </NavigationRail.ListItem>\n      <NavigationRail.ListItem>\n        <NavigationRail.Anchor label=\"Reports\" icon={reportsIcon} href=\"/reports\" />\n      </NavigationRail.ListItem>\n    </NavigationRail.List>\n\n    <NavigationRail.Footer>\n      <NavigationRail.List>\n        <NavigationRail.ListItem>\n          <NavigationRail.Button label=\"Help\" icon={helpIcon} onClick={…} />\n        </NavigationRail.ListItem>\n        <NavigationRail.ListItem>\n          <NavigationRail.Button label=\"Settings\" icon={settingsIcon} onClick={…} />\n        </NavigationRail.ListItem>\n        <NavigationRail.ListItem>\n          <NavigationRail.Button label=\"Profile\" icon={userIcon} onClick={…} />\n        </NavigationRail.ListItem>\n      </NavigationRail.List>\n   </NavigationRail.Footer>\n  </NavigationRail.Content>\n</NavigationRail.Root>\n```",
						"barrelName": "unstable_NavigationRail.Root"
					},
					{
						"name": "Header",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "nav",
						"jsdoc": "`NavigationRail.Header` represents the header (i.e. top) section of the `NavigationRail` and is\nvisually aligned with the page header next to it.\n\nCan contain a logo and a `NavigationRail.ToggleButton` to collapse/expand the `NavigationRail`.\n\n**Note**: This component is expected to hug the top edge of the page.",
						"barrelName": "unstable_NavigationRail.Header"
					},
					{
						"name": "ToggleButton",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [
							{
								"name": "label",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "Customize the accessible label of the toggle button.",
								"defaultValue": "\"Expand navigation\"."
							}
						],
						"baseElement": "button",
						"jsdoc": "`NavigationRail.ToggleButton` toggles the expanded/collapsed state of the `NavigationRail`.\nIt is typically placed inside `NavigationRail.Header`, next to the logo.\n\nWhen this button is clicked, it toggles the internal expanded state of the `NavigationRail`,\nand also calls the `setExpanded` callback prop if provided, to allow syncing with external state.",
						"barrelName": "unstable_NavigationRail.ToggleButton"
					},
					{
						"name": "Content",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "`NavigationRail.Content` is a wraps the main content of the `NavigationRail`, including\nthe primary navigation list and an optional footer.\n\nExample:\n```tsx\n<NavigationRail.Content>\n  <NavigationRail.List>…</NavigationRail.List>\n\n  <NavigationRail.Footer>\n    <NavigationRail.List>…</NavigationRail.List>\n  </NavigationRail.Footer>\n</NavigationRail.Content>\n```",
						"barrelName": "unstable_NavigationRail.Content"
					},
					{
						"name": "List",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The `NavigationRail.List` represents a list of top-level navigation items.\n\nIt should be used within `NavigationRail.Content` and should contain `NavigationRail.ListItem` elements,\nwhich in turn can contain `NavigationRail.Anchor` or `NavigationRail.Button`.\n\nExample (with `NavigationRail.Anchor`):\n```tsx\n<NavigationRail.List>\n  <NavigationRail.ListItem>\n    <NavigationRail.Anchor label=\"Home\" icon={homeIcon} href=\"/\" />\n  </NavigationRail.ListItem>\n  <NavigationRail.ListItem>\n    <NavigationRail.Anchor label=\"Projects\" icon={projectsIcon} href=\"/projects\" />\n  </NavigationRail.ListItem>\n</NavigationRail.List>\n```\n\nExample (with `NavigationRail.Button`):\n```tsx\n<NavigationRail.List>\n  <NavigationRail.ListItem>\n    <NavigationRail.Button label=\"Help\" icon={helpIcon} onClick={…} />\n  </NavigationRail.ListItem>\n  <NavigationRail.ListItem>\n    <NavigationRail.Button label=\"Settings\" icon={settingsIcon} onClick={…}  />\n  </NavigationRail.ListItem>\n</NavigationRail.List>\n```\n\nMultiple `NavigationRail.List` elements can be used together and be separated by a `Divider`.",
						"barrelName": "unstable_NavigationRail.List"
					},
					{
						"name": "ListItem",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "The `NavigationRail.Item` represents a single navigation list item, which should contain\neither a `NavigationRail.Anchor` or a `NavigationRail.Button`.\n\nExample:\n```tsx\n<NavigationRail.ListItem>\n  <NavigationRail.Anchor label=\"Home\" icon={homeIcon} href=\"/\" />\n</NavigationRail.ListItem>\n// or\n<NavigationRail.ListItem>\n  <NavigationRail.Button label=\"Settings\" icon={settingsIcon} onClick={…} />\n</NavigationRail.ListItem>\n```\n\n**Note:** This is a non-interactive wrapper element and should not directly handle user interactions.",
						"barrelName": "unstable_NavigationRail.ListItem"
					},
					{
						"name": "Button",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "icon",
								"type": "string | Element",
								"optional": false
							},
							{
								"name": "label",
								"type": "string",
								"optional": false
							}
						],
						"baseElement": "button",
						"jsdoc": "`NavigationRail.Button` is used for actions that do not navigate to a new page, but rather perform\nan in-page action, such as opening a dialog or menu.\n\nShould be used inside `NavigationRail.ListItem` and must have a short `label` and a recognizable `icon`.\nThe `label` will be shown as a tooltip when the `NavigationRail` is collapsed.\n\nExample:\n```tsx\n<NavigationRail.ListItem>\n  <NavigationRail.Button label=\"Notifications\" icon={notificationsIcon} onClick={showNotificationsDialog} />\n</NavigationRail.ListItem>\n```",
						"barrelName": "unstable_NavigationRail.Button"
					},
					{
						"name": "Anchor",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "icon",
								"type": "string | Element",
								"optional": false
							},
							{
								"name": "label",
								"type": "string",
								"optional": false
							},
							{
								"name": "active",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Whether the anchor is currently active (i.e. represents the current page)."
							}
						],
						"baseElement": "a",
						"jsdoc": "`NavigationRail.Anchor` is used for top-level navigation items that link to major pages.\n\nShould be used inside `NavigationRail.ListItem` and must have a short `label` and a recognizable `icon`.\nThe `label` will be shown as a tooltip when the `NavigationRail` is collapsed.\n\nExample:\n```tsx\n<NavigationRail.ListItem>\n  <NavigationRail.Anchor label=\"Home\" icon={homeIcon} href=\"/\" />\n</NavigationRail.ListItem>\n```",
						"barrelName": "unstable_NavigationRail.Anchor"
					},
					{
						"name": "Footer",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "footer",
						"jsdoc": "`NavigationRail.Footer` is typically used for grouping secondary actions list near the bottom\nof the `NavigationRail`, away from the main navigation items.\n\nExample:\n```tsx\n<NavigationRail.Content>\n  <NavigationRail.List>…</NavigationRail.List>\n\n  <NavigationRail.Footer>\n    <NavigationRail.List>…</NavigationRail.List>\n  </NavigationRail.Footer>\n</NavigationRail.Content>\n```",
						"barrelName": "unstable_NavigationRail.Footer"
					}
				],
				"exportName": "unstable_NavigationRail"
			},
			{
				"name": "Popover",
				"convenience": {
					"name": "Popover",
					"baseProps": ["BaseProps.render"],
					"props": [
						{
							"name": "children",
							"type": "ReactElement<unknown, string | JSXElementConstructor<any>>",
							"optional": false,
							"jsdoc": "The element that will trigger the popover when clicked.\nCommon examples include buttons, links, or form controls.\n\n**Note**: The trigger must be a single interactive element. Do not add a\npopover to a non-interactive static element (such as a `<div>` or `<svg>`). Also,\nthe trigger element must forward its ref and spread its props."
						},
						{
							"name": "content",
							"type": "ReactNode",
							"optional": false,
							"jsdoc": "The content to be displayed inside the popover when the trigger element is hovered or focused."
						},
						{
							"name": "open",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "Whether the content is visible.",
							"defaultValue": "false"
						},
						{
							"name": "placement",
							"type": "Placement | undefined",
							"optional": true,
							"jsdoc": "The placement of the popover.",
							"defaultValue": "\"bottom\""
						},
						{
							"name": "setOpen",
							"type": "((open: boolean) => void) | undefined",
							"optional": true,
							"jsdoc": "A callback that gets called when the\n[`open`](https://ariakit.org/reference/disclosure-provider#open) state\nchanges."
						},
						{
							"name": "unmountOnHide",
							"type": "boolean | undefined",
							"optional": true,
							"jsdoc": "When set to `true`, the content element will be unmounted and removed from\nthe DOM when it's hidden.",
							"defaultValue": "false"
						}
					],
					"baseElement": "div",
					"jsdoc": "A component used to display content in a non-modal window overlay that is placed relative to a trigger element.\n\nExample:\n```tsx\n<Popover\n  content={<>Content</>}\n>\n  <Button>Open</Button>\n</Popover>\n```",
					"barrelName": "unstable_Popover"
				},
				"composition": [],
				"exportName": "unstable_Popover"
			},
			{
				"name": "Table",
				"composition": [
					{
						"name": "HtmlTable",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "table",
						"jsdoc": "A table is a grid of rows and columns that displays data in a structured format.\n\n`Table.HtmlTable` uses native HTML table elements for the table root *and its descendants*.\n\nE.g. `<table>`, `<thead>`, `<tbody>`, `<tr>`, `<th>`, and `<td>`.\n\nRelated: `Table.CustomTable`\n\nExample:\n```tsx\n<Table.HtmlTable> // <table>\n  <Table.Caption>Table Caption</Table.Caption> // <caption>\n\n  <Table.Header> // <thead>\n\t   <Table.Row> // <tr>\n\t     <Table.Cell>Header 1</Table.Cell> // <th>\n\t \t   <Table.Cell>Header 2</Table.Cell> // <th>\n\t   </Table.Row>\n  </Table.Header>\n\n  <Table.Body> // <tbody>\n\t   <Table.Row> // <tr>\n\t\t   <Table.Cell>Cell 1.1</Table.Cell> // <td>\n\t\t   <Table.Cell>Cell 1.2</Table.Cell> // <td>\n\t   </Table.Row>\n\t   <Table.Row> // <tr>\n\t\t   <Table.Cell>Cell 2.1</Table.Cell> // <td>\n\t\t   <Table.Cell>Cell 2.2</Table.Cell> // <td>\n\t   </Table.Row>\n  </Table.Body>\n</Table.HtmlTable>\n```",
						"barrelName": "Table.HtmlTable"
					},
					{
						"name": "CustomTable",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "A table is a grid of rows and columns that displays data in a structured format.\n\n`Table.CustomTable` implements the [WAI-ARIA table pattern](https://www.w3.org/WAI/ARIA/apg/patterns/table/) using\ndivs + appropriate roles for the table root *and its descendants*.\n\nE.g. `<div role=\"table\">`, `<div role=\"row\">`, `<div role=\"columnheader\">`, and `<div role=\"cell\">`.\n\nRelated: `Table.HtmlTable`\n\nExample:\n```tsx\n<Table.CustomTable> // <div role=\"table\">\n  <Table.Caption>Table Caption</Table.Caption> // <div role=\"caption\">\n\n  <Table.Header> // <div role=\"rowgroup\">\n\t   <Table.Row> // <div role=\"row\">\n\t     <Table.Cell>Header 1</Table.Cell> // <div role=\"columnheader\">\n\t \t   <Table.Cell>Header 2</Table.Cell> // <div role=\"columnheader\">\n\t   </Table.Row>\n  </Table.Header>\n\n  <Table.Body>\n\t   <Table.Row> // <div role=\"row\">\n\t\t   <Table.Cell>Cell 1.1</Table.Cell> // <div role=\"cell\">\n\t\t   <Table.Cell>Cell 1.2</Table.Cell> // <div role=\"cell\">\n\t   </Table.Row>\n\t   <Table.Row> // <div role=\"row\">\n\t\t   <Table.Cell>Cell 2.1</Table.Cell> // <div role=\"cell\">\n\t\t   <Table.Cell>Cell 2.2</Table.Cell> // <div role=\"cell\">\n\t   </Table.Row>\n  </Table.Body>\n</Table.CustomTable>\n```",
						"barrelName": "Table.CustomTable"
					},
					{
						"name": "Header",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "`Table.Header` is a column component of cells that labels the columns of a table.\n`Table.Row` and `Table.Cell` can be nested inside a `Table.Header` to create a header row.\n\nIf within a `Table.HtmlTable`: it will render a `<thead>` element.\nIf within a `Table.CustomTable`: it will render a `<div role=\"rowgroup\">` element.\n\nExample:\n```tsx\n<Table.Header>\n\t<Table.Row>\n\t\t<Table.Cell>Header 1</Table.Cell>\n\t\t\t<Table.Cell>Header 2</Table.Cell>\n\t</Table.Row>\n</Table.Header>\n```",
						"barrelName": "Table.Header"
					},
					{
						"name": "Body",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "`Table.Body` is a component that contains the rows of table data.\nMultiple `Table.Row`s and `Table.Cell`s can be nested inside a `Table.Body` to create a table body.\n\nIf within a `Table.HtmlTable`: it will render a `<tbody>` element.\nIf within a `Table.CustomTable`: it will render a `<div>` element.\n\nExample:\n```tsx\n<Table.Body>\n\t<Table.Row>\n\t\t<Table.Cell>Cell 1.1</Table.Cell>\n\t\t<Table.Cell>Cell 1.2</Table.Cell>\n\t</Table.Row>\n\t<Table.Row>\n\t\t<Table.Cell>Cell 2.1</Table.Cell>\n\t\t<Table.Cell>Cell 2.2</Table.Cell>\n\t</Table.Row>\n</Table.Body>\n```",
						"barrelName": "Table.Body"
					},
					{
						"name": "Row",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "`Table.Row` is a component that contains the cells of a table row.\n\nIf within a `Table.HtmlTable`: it will render a `<tr>` element.\nIf within a `Table.CustomTable`: it will render a `<div role=\"row\">` element.\n\nExample:\n```tsx\n<Table.Row>\n\t<Table.Cell>Cell 1.1</Table.Cell>\n\t<Table.Cell>Cell 1.2</Table.Cell>\n</Table.Row>\n```\n\nRows that contain checked checkboxes are considered selected.\nThe `Checkbox` component can be rendered to add selection functionality for the table rows.\n\nExample:\n```tsx\n<Table.Row>\n  <Table.Cell><Checkbox /><Table.Cell>\n  <Table.Cell>Cell 1.1</Table.Cell>\n  <Table.Cell>Cell 1.2</Table.Cell>\n</Table.Row\n```",
						"barrelName": "Table.Row"
					},
					{
						"name": "Caption",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "`Table.Caption` is a component that contains the caption of a table.\n\nIf within a `Table.HtmlTable`: it will render a `<caption>` element.\nIf within a `Table.CustomTable`: it will render a `<div role=\"caption\">` element.\n\nExample:\n```tsx\n<Table.CustomTable> // Or <Table.HtmlTable>\n\t <Table.Caption>Table Caption</Table.Caption>\n\t …\n</Table.CustomTable> // Or </Table.HtmlTable>\n```",
						"barrelName": "Table.Caption"
					},
					{
						"name": "Cell",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "`Table.Cell` is a component that contains the data of a table cell.\n\n- If within a `Table.HtmlTable`: it will render a `<th>` element if also within a `Table.Header`, or a `<td>` element\nif also within a `Table.Body`.\n- If within a `Table.CustomTable`: it will render a `<div role=\"columnheader\">` element if also within a\n`Table.Header`, or a `<div role=\"cell\">` element if also within a `Table.Body`.\n\nExample:\n```tsx\n<Table.Cell>Cell 1.1</Table.Cell>\n```",
						"barrelName": "Table.Cell"
					}
				],
				"exportName": "Table"
			},
			{
				"name": "Tabs",
				"composition": [
					{
						"name": "Provider",
						"baseProps": [],
						"props": [
							{
								"name": "children",
								"type": "ReactNode",
								"optional": true
							},
							{
								"name": "defaultSelectedId",
								"type": "string | null | undefined",
								"optional": true,
								"jsdoc": "The id of the tab whose panel is currently visible. If it's `undefined`, it\nwill be automatically set to the first enabled tab."
							},
							{
								"name": "selectedId",
								"type": "string | null | undefined",
								"optional": true,
								"jsdoc": "The id of the tab whose panel is currently visible. If it's `undefined`, it\nwill be automatically set to the first enabled tab."
							},
							{
								"name": "selectOnMove",
								"type": "boolean | undefined",
								"optional": true,
								"defaultValue": "false"
							},
							{
								"name": "setSelectedId",
								"type": "((selectedId: string | null | undefined) => void) | undefined",
								"optional": true,
								"jsdoc": "Function that will be called when the\n[`selectedId`](https://ariakit.org/reference/tab-provider#selectedid) state\nchanges."
							}
						],
						"jsdoc": "A set of tabs that can be used to switch between different views.\n\n`Tabs` is a compound component with subcomponents exposed for different parts.\n\nExample:\n```tsx\n<Tabs.Provider>\n  <Tabs.TabList>\n    <Tabs.Tab id=\"tab-1\">Tab 1</Tabs.Tab>\n    <Tabs.Tab id=\"tab-2\">Tab 2</Tabs.Tab>\n    <Tabs.Tab id=\"tab-3\">Tab 3</Tabs.Tab>\n  </Tabs.TabList>\n\n  <Tabs.TabPanel tabId=\"tab-1\">Tab 1 content</Tabs.TabPanel>\n  <Tabs.TabPanel tabId=\"tab-2\">Tab 2 content</Tabs.TabPanel>\n  <Tabs.TabPanel tabId=\"tab-3\">Tab 3 content</Tabs.TabPanel>\n</Tabs.Provider>\n```\n\nThe tabs and their panels are connected by matching the `id` prop on the `Tabs.Tab` component with\nthe `tabId` prop on the `Tabs.TabPanel` component.\n\nThe `Tabs` component automatically manages the selected tab state. The initially selected tab can be set using `defaultSelectedId`.\nTo take full control the selected tab state, use the `selectedId` and `setSelectedId` props together.\n\n**Note**: `Tabs` should _not_ be used for navigation; it is only intended for switching smaller views within an existing page.",
						"barrelName": "Tabs.Provider"
					},
					{
						"name": "TabList",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "tone",
								"type": "\"neutral\" | \"accent\" | undefined",
								"optional": true,
								"defaultValue": "\"neutral\""
							}
						],
						"baseElement": "div",
						"jsdoc": "A simple container for the tab buttons.\nShould be used as a child of `Tabs.Provider` and consist of the individual `Tabs.Tab` components.\n\nExample:\n```tsx\n<Tabs.TabList>\n  <Tabs.Tab id=\"tab-1\">Tab 1</Tabs.Tab>\n  <Tabs.Tab id=\"tab-2\">Tab 2</Tabs.Tab>\n  <Tabs.Tab id=\"tab-3\">Tab 3</Tabs.Tab>\n</Tabs.TabList>\n```",
						"barrelName": "Tabs.TabList"
					},
					{
						"name": "Tab",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [
							{
								"name": "id",
								"type": "string",
								"optional": false,
								"jsdoc": "The globally unique id of the tab. This will be used to identify the tab\nand connect it to the corresponding `Tabs.TabPanel` via the `tabId`.\n\nThe `selectedId` state of `Tabs.Provider` will also be based on this id."
							}
						],
						"baseElement": "button",
						"jsdoc": "An individual tab button that switches the selected tab panel when clicked.\n\nShould be used as a child of `Tabs.TabList` and be paired with a `Tabs.TabPanel`,\nconnected using an id.\n\nExample:\n```tsx\n<Tabs.Tab id=\"tab-1\">Tab 1</Tabs.Tab>\n```\n\nStart and end icons can be added by passing `Icon` as children.\n\n```tsx\n<Tabs.Tab id=\"tab-1\">\n  <Icon href={…} />\n  Tab 1\n  <Icon href={…} />\n</Tabs.Tab>\n```",
						"barrelName": "Tabs.Tab"
					},
					{
						"name": "TabPanel",
						"baseProps": [
							"FocusableProps.render",
							"FocusableProps.autoFocus",
							"FocusableProps.disabled",
							"FocusableProps.accessibleWhenDisabled"
						],
						"props": [
							{
								"name": "tabId",
								"type": "string | null",
								"optional": false,
								"jsdoc": "The [`id`](https://ariakit.org/reference/tab#id) of the tab controlling\nthis panel. This connection is used to assign the `aria-labelledby`\nattribute to the tab panel and to determine if the tab panel should be\nvisible.\n\nThis link is automatically established by matching the order of\n[`Tab`](https://ariakit.org/reference/tab) and\n[`TabPanel`](https://ariakit.org/reference/tab-panel) elements in the DOM.\nIf you're rendering a single tab panel, this can be set to a dynamic value\nthat refers to the selected tab."
							},
							{
								"name": "focusable",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Determines if [Focusable](https://ariakit.org/components/focusable)\nfeatures should be active on non-native focusable elements.\n\n**Note**: This prop only turns off the additional features provided by the\n[`Focusable`](https://ariakit.org/reference/focusable) component.\nNon-native focusable elements will lose their focusability entirely.\nHowever, native focusable elements will retain their inherent focusability,\nbut without added features such as improved\n[`autoFocus`](https://ariakit.org/reference/focusable#autofocus),\n[`accessibleWhenDisabled`](https://ariakit.org/reference/focusable#accessiblewhendisabled),\n[`onFocusVisible`](https://ariakit.org/reference/focusable#onfocusvisible),\netc.",
								"defaultValue": "true"
							},
							{
								"name": "unmountOnHide",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "When set to `true`, the content element will be unmounted and removed from\nthe DOM when it's hidden.",
								"defaultValue": "false"
							}
						],
						"baseElement": "div",
						"jsdoc": "The actual content of a tab, shown when the tab is selected. Should be used as a child of `Tabs.Provider`.\nThe `tabId` prop should match the `id` prop of the corresponding `Tabs.Tab` component.\n\nExample:\n```tsx\n<Tabs.TabPanel tabId=\"tab-1\">Tab 1 content</Tabs.TabPanel>\n```",
						"barrelName": "Tabs.TabPanel"
					}
				],
				"exportName": "Tabs"
			},
			{
				"name": "Toolbar",
				"composition": [
					{
						"name": "Group",
						"baseProps": ["BaseProps.render"],
						"props": [
							{
								"name": "variant",
								"type": "\"solid\"",
								"optional": false,
								"jsdoc": "Must be set to `\"solid\"` for now."
							},
							{
								"name": "orientation",
								"type": "\"horizontal\" | \"vertical\" | undefined",
								"optional": true,
								"jsdoc": "The orientation of the toolbar.",
								"defaultValue": "\"horizontal\""
							}
						],
						"baseElement": "div",
						"jsdoc": "A toolbar for grouping related interactive elements.\n\nFollows the [ARIA Toolbar pattern](https://www.w3.org/WAI/ARIA/apg/patterns/toolbar/) for reducing the number of tab stops.\n\nExample:\n```jsx\n<Toolbar.Group variant=\"solid\">\n  <Toolbar.Item render={…} />\n  <Toolbar.Item render={…} />\n  <Toolbar.Item render={…} />\n</Toolbar.Group>\n```\n\nA divider can be displayed between items by rendering the `Divider` component.\n\n```jsx\n<Toolbar.Group variant=\"solid\">\n  <Toolbar.Item render={…} />\n  <Divider orientation=\"vertical\" />\n  <Toolbar.Item render={…} />\n  <Toolbar.Item render={…} />\n</Toolbar.Group>\n```",
						"barrelName": "unstable_Toolbar.Group"
					},
					{
						"name": "Item",
						"baseProps": [],
						"props": [
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement",
								"optional": false,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							}
						],
						"baseElement": "button",
						"jsdoc": "An item within the toolbar.\nShould be used with the `render` prop.\n\nIf rendering an `IconButton`, be sure to append `#icon-large` to the icon URL.\n\nExample:\n```jsx\n<Toolbar.Item\n  render={<IconButton variant=\"ghost\" icon={`${placeholderIcon}#icon-large`} />}\n/>\n```",
						"barrelName": "unstable_Toolbar.Item"
					}
				],
				"exportName": "unstable_Toolbar"
			},
			{
				"name": "Tree",
				"composition": [
					{
						"name": "Root",
						"baseProps": ["BaseProps.render"],
						"props": [],
						"baseElement": "div",
						"jsdoc": "A tree is a hierarchical list of items that can be expanded or collapsed, or optionally selected.\n\n`Tree.Root` is the root component for a tree. `Tree.Item`s are rendered as a flat list in the `Tree.Root` component to create a hierarchical tree structure.\n\nExample:\n```tsx\n<Tree.Root>\n  <Tree.Item label=\"Parent 1\" aria-level={1} aria-posinset={1} aria-setsize={2} />\n  <Tree.Item label=\"Child 1.1\" aria-level={2} aria-posinset={1} aria-setsize={2} />\n  <Tree.Item label=\"Child 1.2\" aria-level={2} aria-posinset={2} aria-setsize={2} />\n  <Tree.Item label=\"Parent 2\" aria-level={1} aria-posinset={2} aria-setsize={2} />\n  <Tree.Item label=\"Child 2.1\" aria-level={2} aria-posinset={1} aria-setsize={1} />\n</Tree.Root>\n```",
						"barrelName": "Tree.Root"
					},
					{
						"name": "Item",
						"baseProps": [],
						"props": [
							{
								"name": "aria-level",
								"type": "number",
								"optional": false,
								"jsdoc": "Specifies the nesting level of the tree item. Nesting levels start at 1."
							},
							{
								"name": "aria-posinset",
								"type": "number",
								"optional": false,
								"jsdoc": "Defines tree item position in the current level of tree items. Integer greater than or equal to 1."
							},
							{
								"name": "aria-setsize",
								"type": "number",
								"optional": false,
								"jsdoc": "Defines tree item set size of the current level."
							},
							{
								"name": "actions",
								"type": "ReactNode[] | undefined",
								"optional": true,
								"jsdoc": "The secondary actions available for the tree item displayed in a dropdown menu. Must be a list of `Tree.ItemAction` components.\n\n```tsx\nactions={[\n  <Tree.ItemAction key={…} icon={…} label={…} />,\n  <Tree.ItemAction key={…} icon={…} label={…} />,\n]}\n```"
							},
							{
								"name": "description",
								"type": "ReactNode",
								"optional": true,
								"jsdoc": "Secondary line of text to display additional information about the tree item."
							},
							{
								"name": "error",
								"type": "string | boolean | undefined",
								"optional": true,
								"jsdoc": "Specifies if the tree item is in an error state.\nThe id for an associated error message (e.g. `<ErrorRegion.Item>`) can be passed as a string.\n\nCan be combined with the `actions` prop to display an error-related action (e.g. \"Retry\").\nThe first action will be made visible by default.",
								"defaultValue": "false"
							},
							{
								"name": "expanded",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Specifies if the tree item is expanded.\n\nUsed to determine if a tree item is a parent node. If `undefined`, it is a leaf node (i.e. not expandable).",
								"defaultValue": "undefined"
							},
							{
								"name": "icon",
								"type": "string | Element | undefined",
								"optional": true,
								"jsdoc": "Icon to be displayed inside the tree item.\n\nCan be a URL of an SVG from the `@stratakit/icons` package, or a JSX element.\n\nFor multiple icons/decorations, use the `unstable_decorations` prop."
							},
							{
								"name": "inlineActions",
								"type": "ReactNode[] | undefined",
								"optional": true,
								"jsdoc": "The secondary actions available for the tree item displayed as icon buttons in a toolbar. Must be a list of `Tree.ItemAction` components.\n\nExample:\n```tsx\ninlineActions={\n  error\n    ? [\n        <Tree.ItemAction key={…} icon={…} label={…} />\n      ]\n    : [\n        <Tree.ItemAction key={…} icon={…} label={…} />,\n        <Tree.ItemAction key={…} icon={…} label={…} />,\n      ]\n}\n```\n\nInline actions should only be used for frequently used and quickly accessible actions.\nAt most two inline actions are displayed. A single action should be specified when tree item has an error.\n\nThe inline actions are normally hidden until the treeitem is hovered or focused.\nWhen the `error` prop is set, the actions will be made visible by default. The first\naction slot should usually be used to display an error-related action."
							},
							{
								"name": "label",
								"type": "ReactNode",
								"optional": true,
								"jsdoc": "The primary label that identifies the tree item and is displayed inside it."
							},
							{
								"name": "onExpandedChange",
								"type": "((expanded: boolean) => void) | undefined",
								"optional": true,
								"jsdoc": "Callback fired when the tree item is expanded.\n\nShould be used with the `expanded` prop."
							},
							{
								"name": "onSelectedChange",
								"type": "((selected: boolean) => void) | undefined",
								"optional": true,
								"jsdoc": "Callback fired when the tree item is selected.\n\nShould be used with the `selected` prop."
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							},
							{
								"name": "selected",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Specifies if the tree item is selected.\n\nIf `undefined`, the tree item is not selectable.",
								"defaultValue": "undefined"
							},
							{
								"name": "unstable_decorations",
								"type": "ReactNode",
								"optional": true,
								"jsdoc": "Decoration(s) to be displayed inside the tree item.\n\nThis is an alternative to the `icon` prop, and can be used to\ndisplay multiple icons or other decorations before the label.\n\nNote: This should _not_ be used together with the `icon` prop."
							}
						],
						"baseElement": "div",
						"jsdoc": "A treeitem is a node in a tree structure that may be expanded or collapsed to reveal or hide its descendants.\n\n`Tree.Item`s can be rendered inside a `Tree.Root`. Additional properties are specified to the `Tree.Item`s to create a hierarchical tree structure.\n\nExample:\n```tsx\n<Tree.Root>\n  <Tree.Item label=\"Parent\" aria-level={1} aria-posinset={1} aria-setsize={1} />\n  <Tree.Item label=\"Child 1\" aria-level={2} aria-posinset={1} aria-setsize={2} />\n  <Tree.Item label=\"Child 2\" aria-level={2} aria-posinset={2} aria-setsize={2}  />\n</Tree.Root>\n```\n\nThe `label` and `icon` props can be used to specify the treeitem's own content.\n\nThe `aria-level` prop is used to specify the nesting level of the treeitem. Nesting levels start at 1.\n\nThe `aria-posinset` and `aria-setsize` props are used to define the treeitem's position in the current level of tree items.\n\nThe `expanded` and `onExpandedChange` props can be used to control the expansion state of a treeitem.\n\nThe `selected` and `onSelectedChange` props can be used to control the selection state of a treeitem.\n\nSecondary actions can be passed into the `actions` prop.",
						"barrelName": "Tree.Item"
					},
					{
						"name": "ItemAction",
						"baseProps": [],
						"props": [
							{
								"name": "label",
								"type": "string",
								"optional": false,
								"jsdoc": "Label for the action.\n\nWill be displayed as a tooltip when the action is an icon-button,\notherwise will be displayed as a label inside the menu-item."
							},
							{
								"name": "dot",
								"type": "string | undefined",
								"optional": true,
								"jsdoc": "A small dot displayed in the corner of the action.\n\nThe value of this prop gets used as the button's \"accessible description\".\n\nExample:\n```tsx\n<Tree.ItemAction\n  label=\"Filter\"\n  dot=\"Some filters applied\"\n  icon={…}\n/>\n```"
							},
							{
								"name": "icon",
								"type": "string | Element | undefined",
								"optional": true,
								"jsdoc": "Icon for the action.\n\nCan be a URL of an SVG from the `@stratakit/icons` package, or a JSX element.\n\nRequired when the action is displayed as an icon-button (i.e. not overflowing)."
							},
							{
								"name": "render",
								"type": "(props: P) => React.ReactNode | React.ReactElement | undefined",
								"optional": true,
								"jsdoc": "Allows the component to be rendered as a different HTML element or React\ncomponent. The value can be a React element or a function that takes in the\noriginal component props and gives back a React element with the props\nmerged.\n\nCheck out the [Composition](https://ariakit.org/guide/composition) guide\nfor more details."
							},
							{
								"name": "visible",
								"type": "boolean | undefined",
								"optional": true,
								"jsdoc": "Controls the visibility of the action (only when the action is displayed as icon-button).\n\nIf `true`, the action is always visible.\nIf `false`, the action is hidden and becomes inaccessible, but still occupies space.\n\nBy default, the action is shown only when the treeitem receives hover/focus. When the\ntreeitem has an `error`, the action will become always visible (i.e. it will default\nto `true` when `error` is set)."
							}
						],
						"baseElement": "button",
						"jsdoc": "A secondary action for `<Tree.Item>`, to be passed into the `actions` prop. The action is typically\ndisplayed as an icon-button or a menu-item (e.g. when overflowing).\n\nBy default, the action appears only when the treeitem has hover/focus or an error. This behavior can\nbe overridden using the `visible` prop.",
						"barrelName": "Tree.ItemAction"
					}
				],
				"exportName": "Tree"
			}
		]
	}
]
