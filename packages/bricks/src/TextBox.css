/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
.ğŸ¥TextBox {
	--âœ¨bg--default: var(--stratakit-color-bg-control-textbox);
	--âœ¨bg--hover: color-mix(
		in oklch,
		var(--âœ¨bg--default) 100%,
		var(--stratakit-color-glow-hue) var(--stratakit-color-bg-glow-base-hover-\%)
	);
	--âœ¨bg--disabled: var(--stratakit-color-bg-control-textbox);
	--âœ¨border--default: var(--stratakit-color-border-neutral-base);
	--âœ¨border--hover: color-mix(
		in oklch,
		var(--âœ¨border--default) 100%,
		var(--stratakit-color-glow-hue) var(--stratakit-color-border-glow-base-hover-\%)
	);
	--âœ¨border--focus: var(--stratakit-color-border-accent-strong);
	--âœ¨border--invalid: var(--stratakit-color-border-critical-base);
	--âœ¨border--disabled: var(--stratakit-color-border-glow-on-surface-disabled);
	--âœ¨color--default: var(--stratakit-color-text-neutral-primary);
	--âœ¨color--placeholder: var(--stratakit-color-text-neutral-secondary);
	--âœ¨color--disabled: var(--stratakit-color-text-neutral-disabled);
	--âœ¨height: 1.5rem;
	--âœ¨padding-inline: var(--stratakit-space-x2);
	/* Dynamically adjust the padding to avoid issues with baseline alignment */
	--âœ¨padding-block: max(0px, (var(--âœ¨height) - var(--stratakit-space-x05) - 1lh) / 2);
	--âœ¨gap: var(--stratakit-space-x1);

	@layer base {
		cursor: var(--ğŸ¥TextBox-cursor);
		font-size: var(--stratakit-font-size-12);
		min-inline-size: 0;

		min-block-size: var(--âœ¨height);
		padding-inline: var(--âœ¨padding-inline);
		border-radius: 4px;

		background-color: var(--ğŸ¥TextBox-background-color);
		color: var(--âœ¨color--default);
		transition: all 150ms ease-out;
		transition-property: background-color, border-color;
		-webkit-tap-highlight-color: transparent;

		--ğŸ¥TextBox-cursor: text;
		--ğŸ¥TextBox-background-color: var(--ğŸŒ€TextBox-state--default, var(--âœ¨bg--default))
			var(--ğŸŒ€TextBox-state--hover, var(--âœ¨bg--hover))
			var(--ğŸŒ€TextBox-state--disabled, var(--âœ¨bg--disabled));
		--ğŸ¥TextBox-border-color: var(--ğŸŒ€TextBox-state--default, var(--âœ¨border--default))
			var(--ğŸŒ€TextBox-state--hover, var(--âœ¨border--hover))
			var(--ğŸŒ€TextBox-state--disabled, var(--âœ¨border--disabled));
		--ğŸ¥TextBox-box-shadow: var(--ğŸŒ€TextBox-state--default, var(--stratakit-shadow-input-base))
			var(--ğŸŒ€TextBox-state--hover, var(--stratakit-shadow-input-base))
			var(--ğŸŒ€TextBox-state--disabled, none);

		/* Styles specific to wrapper ("root") */
		&:where(:not(input, textarea)) {
			position: relative;
			display: inline-flex;
			align-items: center;
			gap: var(--âœ¨gap);

			/* This pseudo-element is used to place a border which does not occupy space. */
			&::before {
				content: "";
				position: absolute;
				inset: 0;
				border-radius: inherit;
				pointer-events: none;
				border: 1px solid var(--ğŸ¥TextBox-border-color);
				box-shadow: var(--ğŸ¥TextBox-box-shadow);
				transition: border-color 150ms ease-out;
			}

			/* Propagate padding-inline-start to the nested input/textarea when there is no decoration _before_ it. */
			&:where(:not(:has(.ğŸ¥TextBoxDecoration ~ :is(input, textarea)))) {
				padding-inline-start: 0;

				:where(input, textarea) {
					padding-inline-start: var(--âœ¨padding-inline);
				}
			}

			/* Propagate padding-inline-end to the nested input/textarea when there is no decoration _after_ it. */
			&:where(:not(:has(:is(input, textarea) ~ .ğŸ¥TextBoxDecoration))) {
				padding-inline-end: 0;

				:where(input, textarea) {
					padding-inline-end: var(--âœ¨padding-inline);
				}
			}
		}

		/* Styles specific to input/textarea (self) */
		&:where(input, textarea) {
			box-shadow: var(--ğŸ¥TextBox-box-shadow);
		}

		/* Styles specific to input/textarea (self and nested) */
		&:where(input, textarea),
		:where(input, textarea) {
			appearance: none;
			line-height: 1.3; /* This is a safe value for Inter â€” lower values will be ignored. */
			min-inline-size: 0;
			border: 1px solid var(--ğŸ¥TextBox-border-color);
			cursor: var(--ğŸ¥TextBox-cursor);
			padding-block: var(--âœ¨padding-block);

			&::placeholder {
				color: var(--âœ¨color--placeholder);
				opacity: 1;
				user-select: none;
			}
		}

		/* Styles specific to textarea (self and nested) */
		&:where(textarea),
		:where(textarea) {
			resize: vertical;
			resize: block;
		}

		/* Styles specific to input/textarea (nested only, "invisible") */
		:where(input, textarea) {
			border: none;
			background-color: var(--ğŸ¥TextBox-background-color);
			border-radius: inherit;
			outline: unset !important;
			flex: 999;
			align-self: stretch;
			transition: background-color 150ms ease-out;
			min-height: inherit;
		}
	}

	@layer states {
		@media (any-hover: hover) {
			&:where(:hover) {
				--ğŸŒ€TextBox-state: var(--ğŸŒ€TextBox-state--hover);
			}
		}

		&:where(:has(:is(input, textarea):focus-visible), :is(input, textarea):focus-visible) {
			outline: var(--ğŸ¥focus-outline);
			outline-offset: var(--ğŸ¥focus-outline-offset);
			--ğŸ¥TextBox-border-color: var(--âœ¨border--focus);
			--ğŸ¥Icon-color: var(--stratakit-color-icon-accent-strong);
		}

		@supports not selector(:has(+ *)) {
			&:where(:not(input, textarea):focus-within) {
				outline: var(--ğŸ¥focus-outline);
				outline-offset: var(--ğŸ¥focus-outline-offset);
				--ğŸ¥TextBox-border-color: var(--âœ¨border--focus);
				--ğŸ¥Icon-color: var(--stratakit-color-icon-accent-strong);
			}
		}

		&:where(
				:is(:user-invalid, [aria-invalid="true"]),
				:has(:is(input, textarea):is(:user-invalid, [aria-invalid="true"]))
			) {
			--ğŸ¥Icon-color: var(--stratakit-color-icon-critical-base);
			--ğŸ¥TextBox-border-color: var(--âœ¨border--invalid);
		}

		&:where(
				:is(:disabled, [aria-disabled="true"], [data-_sk-disabled="true"]),
				:has(:is(input, textarea):is(:disabled, [aria-disabled="true"]))
			) {
			--ğŸŒ€TextBox-state: var(--ğŸŒ€TextBox-state--disabled);
			color: var(--âœ¨color--disabled);
			--ğŸ¥TextBox-cursor: not-allowed;
		}
	}

	@layer base.ğŸŒ€ {
		/* Cyclic toggles for default/hover/disabled states. See https://kizu.dev/cyclic-toggles/ */
		--ğŸŒ€TextBox-state: var(--ğŸŒ€TextBox-state--default);
		--ğŸŒ€TextBox-state--default: var(--ğŸŒ€TextBox-state,);
		--ğŸŒ€TextBox-state--hover: var(--ğŸŒ€TextBox-state,);
		--ğŸŒ€TextBox-state--disabled: var(--ğŸŒ€TextBox-state,);
	}
}

.ğŸ¥TextBoxDecoration {
	@layer base {
		flex-shrink: 0;
	}
}

@media (forced-colors: active) {
	.ğŸ¥TextBox {
		--ğŸ¥TextBox-background-color: Field;
		--ğŸ¥TextBox-border-color: CanvasText;
		color: FieldText;

		&:where(
				:is(:disabled, [aria-disabled="true"], [data-_sk-disabled="true"]),
				:has(:is(input, textarea):is(:disabled, [aria-disabled="true"]))
			) {
			--ğŸ¥TextBox-border-color: GrayText;
			color: GrayText;
		}
	}
}
